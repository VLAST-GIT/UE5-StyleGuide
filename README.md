# UE5 스타일 가이드 (ver. VLAST)

<br>

[ue5-style-guide](https://github.com/Allar/ue5-style-guide#structure-assettypes)를 기반으로 작성되었으며, 기존 VLAST 스타일 가이드와 아래의 자료들을 참고해 변형되었습니다.

>[UE4 코딩표준](https://docs.unrealengine.com/4.26/ko/ProductionPipelines/DevelopmentSetup/CodingStandard/)  
[POCU 아카데미용 C# 코딩 표준](https://docs.popekim.com/ko/coding-standards/pocu-csharp)  
[POCU 아카데미용 C++ 코딩 표준](https://docs.popekim.com/ko/coding-standards/pocu-cpp)  
[언리얼 엔진 마켓플레이스 가이드라인](https://www.unrealengine.com/ko/marketplace-guidelines?sessionInvalidated=true)  
[Recommended Asset Naming Conventions](https://docs.unrealengine.com/4.27/ko/ProductionPipelines/AssetNaming/)  
[LyraStarterGame 샘플 프로젝트](https://www.unrealengine.com/marketplace/en-US/product/lyra)  
메가스캔 폴더 디렉터리 구조

<br>
<br>

## **목차**
- [**중요한 용어들**](#중요한-용어들)
  - [맵(map)과 레벨(level)](#맵map과-레벨level)
  - [명명 규칙 종류](#명명-규칙-종류)
    - [파스칼 케이스 (PascalCase)](#파스칼-케이스-PascalCase)
    - [카멜 케이스 (camelCase)](#카멜-케이스-camelCase)
    - [스네이크 케이스 (snake_case)](#스네이크-케이스-snake_case)
  - [변수(Variable)와 프로퍼티(Property)](#변수variable와-프로퍼티property))
    - [프로퍼티(Property)](#프로퍼티-property)
    - [변수(Variable)](#변수-variable)
  - [접근 제어자 (Access Modifier)](#접근-제어자-access-modifier)
    - [Public](#public)
    - [protected](#protected)
    - [private](#private)
  - [오류와 버그](#오류와-버그)
    - [오류](#오류)
    - [버그](#버그)
- [**00. 원칙들**](#00-원칙들)
  - [00.1 당신이 기존에 어떤 스타일을 가지고 있었든, VLAST 소속의 UE 작업자는 모두 이 스타일 가이드를 따라 작업해야 합니다.](#001-당신이-기존에-어떤-스타일을-가지고-있었든-vlast-소속의-ue-작업자는-모두-이-스타일-가이드를-따라-작업해야-합니다)
  - [00.2 프로젝트는 아무리 많은 사람이 참여했다 하더라도, 이 스타일 가이드에 따라 모두 한 사람이 작업한 것처럼 보여야 합니다.](#002-프로젝트는-아무리-많은-사람이-참여했다-하더라도-이-스타일-가이드에-따라-모두-한-사람이-작업한-것처럼-보여야-합니다)
  - [00.3 스타일 가이드를 지키지 않는 팀원을 그대로 내버려두어선 안됩니다.](#003-스타일-가이드를-지키지-않는-팀원을-그대로-내버려두어선-안됩니다)
- [**01. 금지된 사항들**](#01-금지된-사항들)
  - [01.1 금지된 문자](#011-금지된-문자)
- [**02. 엔진 기본 Config 설정**](#02-엔진-기본-config-설정)
  - [02.1 BaseEditorPerProjectUserSettings.ini](#021-baseeditorperprojectusersettingsini)
    - [02.1.1 Developers 폴더 사용 편의를 위한 설정](#0211-developers-폴더-사용-편의를-위한-설정)
    - [02.1.2 블루프린트 코딩 표준 준수를 위한 설정](#0212-블루프린트-코딩-표준-준수를-위한-설정)
- [**1. 에셋 명명 규칙**](#1-에셋-명명-규칙)
  - [1.1 에셋명 기본 형식: `접두사_기본에셋명_세부변형_접미사`](#11-에셋명-기본-형식-접두사_기본에셋명_세부변형_접미사)
    - [1.1 에셋 명명 예](#11의-예시들)
  - [1.2 에셋 접두사 & 접미사 테이블](#12-에셋-접두사--접미사-테이블)
    - [1.2.1 흔히 사용되는 에셋](#121-흔히-사용되는-에셋)
    - [1.2.2 애니메이션 (Animations)](#122-애니메이션-animations)
    - [1.2.3 인공 지능 (Artificial Intelligence)](#123-인공-지능-artificial-intelligence)
    - [1.2.4 블루프린트 (Blueprints)](#124-블루프린트-blueprints)
    - [1.2.5 머티리얼 (Materials)](#125-머티리얼-materials)
    - [1.2.6 텍스처 (Textures)](#126-텍스처-textures)
      - [1.2.6.1 패킹된 텍스처 (Texture Packing)](#1261-패킹된-텍스처-texture-packing)
    - [1.2.7 기타 (Miscellaneous)](#127-기타-miscellaneous)
    - [1.2.8 페이퍼 2D (Paper 2D)](#128-페이퍼-2d-paper-2d)
    - [1.2.9 피직스 (Physics)](#129-피직스-physics)
    - [1.2.10 사운드 (Sounds)](#1210-사운드-sounds)
    - [1.2.11 유저 인터페이스 (User Interface)](#1211-유저-인터페이스-user-interface)
    - [1.2.12 FX](#1212-fx)
    - [1.2.13 미디어 (Media)](#1213-미디어-media)
- [**2. Content 폴더 디렉터리 구조**](#2-content-폴더-디렉터리-구조)
  - [2.0 Content 폴더 디렉터리 구조 예제](#20-content-폴더-디렉터리-구조-예제)
  - [2.1 폴더명 규칙](#21-폴더명-규칙)
    - [2.1.1 항상 파스칼 케이스(PascalCase)를 사용할 것](#211-항상-파스칼-케이스pascalcase를-사용할-것)
    - [2.1.2 공백(스페이스바)을 사용하지 말 것](#212-공백스페이스바을-사용하지-말-것)
    - [2.1.3 영문과 숫자 이외의 문자(특수문자 포함)를 사용하지 말 것](#213-영문과-숫자-이외의-문자특수문자-포함를-사용하지-말-것)
  - [2.2 최상위 폴더 규칙](#22-최상위-폴더-규칙)
    - [2.2.1 최상위 폴더 바깥에 에셋을 두어선 안됩니다.](#221-최상위-폴더-바깥에-에셋을-두어선-안됩니다)
    - [2.2.2 최상위 폴더 규칙은 이주 충돌을 감소시켜줍니다.](#222-최상위-폴더-규칙은-이주-충돌을-감소시켜줍니다)
      - [2.2.2.1 마스터 머티리얼 이주 충돌 예시](#2221-마스터-머티리얼-이주-충돌-예시)
    - [2.2.3 최상위 폴더 규칙을 준수하는 샘플, 템플릿, 마켓플레이스 콘텐츠는 폴더 구조를 수정하지 않습니다.](#223-최상위-폴더-규칙을-준수하는-샘플-템플릿-마켓플레이스-콘텐츠는-폴더-구조를-수정하지-않습니다)
    - [2.2.4 다른 프로젝트로 자주 이주될 수 있는 에셋 그룹은 별도의 최상위 폴더를 가져야 합니다.](#224-다른-프로젝트로-자주-이주될-수-있는-에셋-그룹은-별도의-최상위-폴더를-가져야-합니다)
  - [2.3 로컬 테스트는 `Developers` 폴더 내에서 해야합니다.](#23-로컬-테스트는-developers-폴더-내에서-해야합니다)
  - [2.4 모든 레벨 에셋은 `Maps` 폴더 내에 위치해야 합니다.](#24-모든-레벨-에셋은-maps-폴더-내에-위치해야-합니다)
  - [2.5 프로젝트에 핵심적인 블루프린트 및 기타 에셋은 `Core` 폴더 내에 위치합니다.](#25-프로젝트에-핵심적인-블루프린트-및-기타-에셋은-core-폴더-내에-위치합니다)
  - [2.6 이름이 `Assets`인 폴더를 만들지 마십시오.](#26-이름이-assets인-폴더를-만들지-마십시오)
  - [2.7 이름이 `Meshes`, `Textures`, `Materials`인 `에셋유형` 폴더를 만들지 마십시오.](#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오)
    - [2.7.1 `Characters` 이하 폴더에는 적용하지 않음.](#271-characters-이하-폴더에는-적용하지-않음)
  - [2.8 여러 에셋과 공유되는 에셋들은 `Common` 폴더 내에 위치합니다.](#28-여러-에셋과-공유되는-에셋들은-common-폴더-내에-위치합니다)
  - [2.9 `MaterialLibrary`](#29-materiallibrary)
  - [2.10 리디렉터, 비어있는 폴더](#210-리디렉터-비어있는-폴더)
- [**3. 블루프린트 코딩 표준**](#3-블루프린트-코딩-표준)
  - [시작하기 전](#시작하기-전)
  - [3.0 기본 원칙](#30-기본-원칙)
  - [**3.1 컴파일과 런타임**](#31-컴파일과-런타임)
    - [3.1.1 컴파일](#311-컴파일)
    - [3.1.2 런타임](#312-런타임)
  - [**3.2 변수**](#32-변수)
    - [3.2.1 변수 이름은 명사여야 합니다.](#321-변수-이름은-명사여야-합니다)
    - [3.2.2 `Public 변수`에는 `파스칼 케이스`를 사용합니다.](#322-public-변수에는-파스칼-케이스를-사용합니다)
    - [3.2.3 `불리언 변수`는 `접두사 b-`를 붙입니다.](#323-불리언-변수는-접두사-b-를-붙입니다)
    - [3.2.4 불리언 변수는 Is, Can, Has, Should와 같은 의문형 동사를 가질 수 있습니다.](#324-불리언-변수는-is-can-has-should와-같은-의문형-동사를-가질-수-있습니다)
    - [3.2.5 불리언 변수 이름은 예/아니오로 명확하게 대답할 수 있어야 합니다.](#325-불리언-변수-이름은-예아니오로-명확하게-대답할-수-있어야-합니다)
    - [3.2.6 불리언 변수로 복잡한 상태를 정의하지 마십시오.](#326-불리언-변수로-복잡한-상태를-정의하지-마십시오)
    - [3.2.7 `private`, `protected` 변수에는 `접두사 m-`을 붙입니다.](#327-private-protected-변수에는-접두사-m-을-붙입니다)
      - [3.2.7.1 private 변수](#3271-private-변수)
      - [3.2.7.2 protected로 의도된 변수](#3272-protected로-의도된-변수)
      - [3.2.7.3 private/protected 변수 이름 예시](#3273-privateprotected-변수-이름-예시)
    - [3.2.8 변수가 속한 클래스를 고려해 불필요한 의미 중복을 피하십시오.](#328-변수가-속한-클래스를-고려해-불필요한-의미-중복을-피하십시오)
    - [3.2.9 기본 자료형 변수에 자료형 이름을 포함하지 마십시오.](#329-기본-자료형-변수에-자료형-이름을-포함하지-마십시오)
    - [3.2.10 배열은 복수형 이름을 가져야 합니다.](#3210-배열은-복수형-이름을-가져야-합니다)
    - [3.2.11 구조체의 멤버변수는 모두 파스칼 케이스를 따릅니다.](#3211-구조체의-멤버변수는-모두-파스칼-케이스를-따릅니다)
    - [3.2.12 함수의 매개변수와 지역변수는 모두 카멜 케이스를 따릅니다.](#3212-함수의-매개변수와-지역변수는-모두-카멜-케이스를-따릅니다)
    - [3.2.13 런타임 중 변경되어선 안되는 상수](#3213-런타임-중-변경되어선-안되는-상수)
    - [3.2.14 변수 툴팁](#3214-변수-툴팁)
    - [3.2.15 슬라이더 및 값 범위](#3215-슬라이더-및-값-범위)
    - [3.2.16 카테고리](#3216-카테고리)
    - [3.2.17 고급 디스플레이 옵션](#3217-고급-디스플레이-옵션)
    - [3.2.18 기타 고급(Advanced) 변수 설정](#3218-기타-고급advanced-변수-설정)
  - [**3.3 함수(Functions), 이벤트(Events)**](#33-함수functions-이벤트events)
    - [3.3.1 함수를 만드는 올바른 태도](#331-함수를-만드는-올바른-태도)
    - [3.3.2.함수는 항상 동사로 시작해야 합니다.](#332-함수는-항상-동사로-시작해야-합니다)
    - [3.3.3 순수하게 값을 계산하거나 가져오기 위한 함수는 `퓨어(Pure) 함수`로 만들어야 합니다.](#333-순수하게-값을-계산하거나-가져오기-위한-함수는-퓨어pure-함수로-만들어야-합니다)
    - [3.3.4 퓨어 함수의 이름은 `Get- 접두사`로 시작해 무엇을 가져오는지 알 수 있게 지어야 합니다.](#334-퓨어함수의-이름은-get--접두사로-시작해-무엇을-가져오는지-알-수-있게-지어야-합니다)
    - [3.3.5 불리언을 반환하는 함수는 질문을 해야합니다.](#335-불리언을-반환하는-함수는-질문을-해야합니다)
    - [3.3.6 함수 접근제어자](#336-함수-접근제어자)
      - [3.3.6.1 외부 호출이 필요한 함수만 `Public 함수`로 정의하십시오.](#3361-외부-호출이-필요한-함수만-public-함수로-정의하십시오)
      - [3.3.6.2 그 외의 모든 함수는 `protected, private 함수`로 정의하십시오.](#3362-그-외의-모든-함수는-protected-private-함수로-정의하십시오)
      - [3.3.6.3 `Public 함수`는 `파스칼 케이스`, `protected, private 함수`는 `카멜 케이스`를 사용합니다.](#3363-public-함수는-파스칼-케이스-protected-private-함수는-카멜-케이스를-사용합니다)
    - [3.3.7 모든 Public 함수에는 `함수 설명(Description)`이 있어야 합니다.](#337-모든-public-함수에는-함수-설명이-있어야-합니다)
    - [3.3.8 외부 접근이 빈번한 변수에는 `Get, Set 함수`를 만드십시오.](#338-외부-접근이-빈번한-변수에는-get-set-함수를-만드십시오)
      - [3.3.8.1 외부 접근자는 언제나 함수를 통해 접근](#3381-외부-접근자는-언제나-함수를-통해-접근)
    - [3.3.9 노드는 특정 기능 단위로 `코멘트 블록`으로 묶어 무엇을 위한 노드 그룹인지 설명합니다.](#339-노드는-특정-기능-단위로-코멘트-블록으로-묶어-무엇을-위한-노드-그룹인지-설명합니다)
    - [3.3.10 모든 함수는 `반환 노드(Return Node)`를 가지고 있어야 합니다.](#3310-모든-함수는-반환-노드return-node를-가지고-있어야-합니다)
    - [3.3.11 Switch 문의 `Default 케이스`는 항상 추가해야 합니다.](#3311-switch-문의-default-케이스는-항상-추가해야-합니다)
    - [3.3.12 두 번 이상 중복되는 노드 그룹은 함수화를 고려해야 합니다.](#3312-두-번-이상-중복되는-노드-그룹은-함수화를-고려해야-합니다)
    - [3.3.13 프로젝트 전용 블루프린트 오류보고 함수](#3313-프로젝트-전용-블루프린트-오류보고-함수)
    - [3.3.14 함수의 `참조형(Reference)` 매개변수에는 기본적으로 Null이 들어오지 않는다고 가정합니다.](#3314-함수의-참조형reference-매개변수에는-기본적으로-null이-들어오지-않는다고-가정합니다)
    - [3.3.15 함수의 참조형 매개변수가 예외적으로 Null을 허용할 경우, 매개변수명 뒤에 `-OrNull 접미사`를 붙입니다.](#3315-함수의-참조형-매개변수가-예외적으로-null을-허용할-경우-매개변수명-뒤에--ornull-접미사를-붙입니다)
    - [3.3.16 함수가 참조형을 반환할 경우 Null을 반환하지 않습니다.](#3316-함수가-참조형을-반환할-경우-null을-반환하지-않습니다)
    - [3.3.17 예외적으로 Null 반환이 가능한 함수의 경우 함수명 뒤에 `-OrNull 접미사`를 붙입니다.](#3317-예외적으로-null-반환이-가능한-함수의-경우-함수명-뒤에--ornull-접미사를-붙입니다)
    - [3.3.18 이벤트 핸들러 및 디스패처는 `On- 접두사`로 시작해야 합니다.](#3318-이벤트-핸들러-및-디스패처는-on--접두사로-시작해야-합니다)
    - [3.3.19 원격 프로시저 호출은 그 대상이 앞에 와야합니다.](#3319-원격-프로시저-호출은-그-대상이-앞에-와야합니다)
  - [**3.4 데이터 유효성 검증 원칙**](#34-데이터-유효성-검증-원칙)
    - [3.4.1 프로그램의 외부와 내부](#341-프로그램의-외부와-내부)
    - [3.4.2 경계 지점에서의 데이터 유효성 검증과 예외처리](#342-경계-지점에서의-데이터-유효성-검증과-예외처리)
    - [3.4.3 유효성 검증을 통과한 프로그램 내부의 로직](#343-유효성-검증을-통과한-프로그램-내부의-로직)
  - [**3.5 기타**](#35-기타)
    - [3.5.1 블루프린트 노드는 대부분의 경우 왼쪽에서 오른쪽으로 진행돼야 합니다.](#351-블루프린트-노드는-대부분의-경우-왼쪽에서-오른쪽으로-진행돼야-합니다)
    - [3.5.2 역순으로 돌아가는 실행흐름을 만들지 말아야 합니다.](#352-역순으로-돌아가는-실행흐름을-만들지-말아야-합니다)
    - [3.5.3 노드 정렬의 기준은 실행흐름 와이어(흰색 실선) 입니다.](#353-노드-정렬의-기준은-실행흐름-와이어흰색-실선-입니다)
- [**4. 소스컨트롤 (버전관리)**](#4-소스컨트롤-버전관리)
  - [4.1 소스 컨트롤은 반드시 켜져있어야 합니다.](#41-소스-컨트롤은-반드시-켜져있어야-합니다)
  - [4.2 플러그인, 프로젝트 세팅을 변경한 뒤 체크인하지 마십시오.](#42-플러그인-프로젝트-세팅을-변경한-뒤-체크인하지-마십시오)
- [**5. 모델링**](#5-모델링)
  - [5.1 한 스태틱 메시와 연관된 머티리얼과 텍스처들은 반드시 올바른 에셋 명명 규칙을 지켜야 합니다.](#51-한-스태틱-메시와-연관된-머티리얼과-텍스처들은-반드시-올바른-에셋-명명-규칙을-지켜야-합니다)
  - [5.2 모든 메시는 UV가 있어야 합니다.](#52-모든-메시는-uv가-있어야-합니다)
  - [5.3 메시의 피벗이 메시와 떨어져있어선 안됩니다.](#53-메시의-피벗이-메시와-떨어져있어선-안됩니다)
  - [5.4 모든 메시는 콜리전이 있어야 합니다.](#54-모든-메시는-콜리전이-있어야-합니다)
  - [5.5 모든 메시는 DCC 툴에서부터 올바른 실측 크기로 작업되어야 합니다.](#55-모든-메시는-dcc-툴에서부터-올바른-실측-크기로-작업되어야-합니다)
  - [5.6 스태틱 메시 FBX Import 옵션](#56-스태틱-메시-fbx-import-옵션)
    - [5.6.1 나나이트 빌드 체크](#561-나나이트-빌드-체크)
    - [5.6.2 라이트맵 UV 생성 체크해제](#562-라이트맵-uv-생성-체크해제)
- [**6. 텍스처**](#6-텍스처)
  - [6.1 모든 텍스처는 2의 거듭제곱 크기여야 합니다.](#61-모든-텍스처는-2의-거듭제곱-크기여야-합니다)
  - [6.2 텍스처의 최대 크기는 8K (8192px) 입니다.](#62-텍스처의-최대-크기는-8k-8192px-입니다)
  - [6.3 텍스처에는 올바른 그룹이 할당되어야 합니다.](#63-텍스처에는-올바른-그룹이-할당되어야-합니다)
- [**7. 머티리얼**](#7-머티리얼)
  - [7.1 변수 이름은 파스칼 케이스로 짓되, 단어 사이에 띄어쓰기를 넣어주세요.](#71-변수-이름은-파스칼-케이스로-짓되-단어-사이에-띄어쓰기를-넣어주세요)
  - [7.2 4.27버전부터 도입된 Named Reroutes 기능을 활용해주세요.](#72-427버전부터-도입된-named-reroutes-기능을-활용해주세요)
- [**8. 캐릭터 (리깅)**](#8-캐릭터-리깅)
  - [8.1 모든 캐릭터는 에픽 표준 본 구조를 따라 리깅되어야 합니다.](#81-모든-캐릭터는-에픽-표준-본-구조를-따라-리깅되어야-합니다)
  - [8.2 모듈식 캐릭터 본 구조](#82-모듈식-캐릭터-본-구조)
    - [8.2.1 Body, Top, Bottom, Feet 모듈](#821-body-top-bottom-feet-모듈)
    - [8.2.2 Face 모듈](#822-face-모듈)
    - [8.2.3 Hair 모듈](#823-hair-모듈)
- [**9. 레벨디자인**](#9-레벨디자인)
- [**10. 라이팅**](#10-라이팅)
  - [10.1 모든 라이트는 무버블이어야 합니다.](#101-모든-라이트는-무버블이어야-합니다)
  - [10.2 더이상 리플렉션 캡처를 사용하지 않습니다.](#102-더이상-리플렉션-캡처를-사용하지-않습니다)
- [**스타일 변경 이력**](#스타일-변경-이력)




<br>
<br>

## 중요한 용어들


### 맵(map)과 레벨(level)

맵(map)은 일반적으로 게임플레이의 월드가 되는 레벨(level)을 의미합니다.  

<br>

### 명명 규칙 종류
 #### 파스칼 케이스 (PascalCase)  
 - 띄어쓰기를 모두 붙여서 표현합니다. 즉, 공백이 없습니다.  
 - 각 단어의 첫 글자는 대문자가 됩니다.   
 - 예시는 다음과 같습니다.  
 `DesertEagle`, `StyleGuide`, `ASeriesOfWords`.

 #### 카멜 케이스 (camelCase) 
 - 파스칼 케이스와 비슷하지만 첫 문자는 항상 소문자입니다
 - 예시는 다음과 같습니다.  
 `desertEagle`, `styleGuide`, `aSeriesOfWords`.

 #### 스네이크 케이스 (snake_case)
 - 띄어쓰기를 밑줄(언더바)로 표시합니다.  
 - 일반적으로 모두 소문자로 표시하지만, 경우에 따라 모두 대문자로 표시하기도 합니다.  
 - 예시는 다음과 같습니다.  
 `desert_Eagle`, `style_guide`, `A_SERIES_OF_WORDS`.

<br>

### 변수(Variable)와 프로퍼티(Property)
 일반적인 맥락에서, 변수와 프로퍼티는 서로 혼용이 가능합니다. 만약 동일한 문맥 내에서 두 용어가 혼용되는 경우 정확한 의미는 다음과 같습니다.  

 

 #### 프로퍼티 (Property)
 일반적으로 클래스 내부 멤버로서 정의된 변수를 의미합니다. 예를 들어, `BP_Bomb` 클래스가 변수 `bExploded`를 멤버로 가지고 있다면, `bExploded`는 `BP_Bomb`의 프로퍼티입니다.  
 
 
 
 #### 변수 (Variable)
 일반적으로 함수의 매개변수 또는 함수 내부의 지역변수로 정의된 변수를 의미합니다.  
 
<br>

### 접근 제어자 (Access Modifier)
접근 제어자는 클래스의 멤버 변수와 함수를 선언할 때 이 변수와 함수에 접근 가능한 대상의 범위를 제한하는 역할을 합니다. 블루프린트에서 사용할 수 있는 접근 제어자는 `Public`, `protected`, `private`가 있습니다.  

#### Public
멤버가 공개되어 클래스 외부 어디에서든 접근 가능  

#### protected 
하위 클래스로만 멤버가 공개되어 상속받은 클래스까지만 접근 가능  

#### private 
공개가 제한되어 멤버를 선언한 클래스 자신만 접근 가능

<br>

### 오류와 버그

#### 오류
컴파일 오류는 잘못된 문법 사용 등 컴파일 자체를 불가능하게 만드는 문제를 말합니다.  

런타임 오류는 게임 실행 도중 만난 예기치 못한 상황들을 말합니다. 이런 오류의 예시는 플레이어로부터 입력받은 값이 잘못되었거나, 라이브링크 데이터가 갑자기 끊기는 상황 등이 있습니다.  

런타임 오류는 실행 도중 발생할 수도 있다고 미리 예측 가능한 것들이기 때문에, 런타임 오류가 발생하더라도 여전히 프로그램을 진행시킬 수 있도록 프로그램은 이런 예외 상황에 대비한 적절한 예외처리 로직을 가지고 있어야 합니다.  

데이터 유효성 검증과 적절한 예외처리 방법에 대해서는 [데이터 유효성 검증 원칙](#34-데이터-유효성-검증-원칙)을 참고해주세요.

#### 버그
버그는 게임(프로그램) 실행 도중 일어날 수 없다고 가정한 상황이 일어난 것입니다. 함수 실행의 전제조건이 충족되었는데 함수 실행 결과가 예상과 다르게 나오는 상황이 좋은 예시입니다. 버그는 오류와 같은 예기치 못한 상황이 아닌, 프로그램의 로직 자체가 잘못된 상황입니다. 때문에 버그가 발생한다면 그 게임의 진행은 더이상 예측 자체가 불가능해집니다. 버그 상황에서도 올바르게 작동하도록 대처하는 것은 불가능하며, 버그는 발견 즉시 다시 일어나지 않도록 로직 자체를 고쳐야 합니다.


**[⬆ Back to Top](#목차)**

<br>
<br>


## **00. 원칙들**


### **00.1** 당신이 기존에 어떤 스타일을 가지고 있었든, VLAST 소속의 UE 작업자는 모두 이 스타일 가이드를 따라 작업해야 합니다.  

만약 이 스타일 가이드에 변경이 필요하다 생각한다면, 팀에 새로운 스타일을 제시하고 논의하시면 됩니다.  


### **00.2** 프로젝트는 아무리 많은 사람이 참여했다 하더라도, 이 스타일 가이드에 따라 모두 한 사람이 작업한 것처럼 보여야 합니다.

하나의 스타일 가이드를 따라 협업하는 프로젝트는 마치 한 사람이 제작한 것처럼 일관성이 유지됩니다. 이는 작업 과정에서의 모호성을 없애고 다른 팀원의 작업에 대한 불확실한 짐작을 할 필요가 없도록 만들어 줍니다. 그 결과 팀은 더 나은 생산성을 얻게 되며, 유지보수가 쉬워지게 됩니다.


### **00.3** 스타일 가이드를 지키지 않는 팀원을 그대로 내버려두어선 안됩니다.

만약 당신이 스타일 가이드를 지키지 않은 구조, 에셋명, 코드 등을 보게 된다면, 당신은 즉시 그것을 작성한 팀원에게 이를 알리고 스타일 가이드를 지키도록 정정해주어야 합니다.

모든 사람이 같은 스타일 가이드를 지킨다는 것은 팀원 간의 질문과 답변을 더욱 쉽게 해줍니다. 아무렇게나 꼬아놓은 블루프린트를 풀거나 알 수 없는 변수명으로 가려진 머티리얼에 생긴 문제를 해결해주는 걸 좋아하는 사람은 없습니다.

명확한 스타일 가이드가 없는 팀은 협업 능력이 없는 팀입니다.

**[⬆ Back to Top](#목차)**

<br>
<br>

## **01. 금지된 사항들**


### **01.1** 금지된 문자

아래의 문자들은 에셋명, 폴더명, 변수명 등 프로젝트 내 어디에서도 사용되어선 안됩니다.  
* ` ` 공백 (스페이스바)
* `\` 백슬래시 기호
* `#!@$%` 대부분의 특수 기호
* 한글 등 모든 유니코드 문자 (즉, 영문이 아닌 대부분의 문자)


즉, 다음의 문자들만 허용됩니다.
* `A-Z` ABCDEFGHIJKLMNOPQRSTUVWXYZ
* `a-z` abcdefghijklmnopqrstuvwxyz
* `0-9` 0123456789
* `_` 밑줄(언더바)

금지된 문자를 사용하지 않는 것은 모든 데이터의 모든 플랫폼으로의 포팅 호환성을 높여줍니다.

**[⬆ Back to Top](#목차)**

<br>
<br>

## **02. 엔진 기본 Config 설정**

엔진의 디폴트 환경변수로 설정해두면 유용한 환경변수 설정들을 다룹니다.  
엔진 기본 환경변수 파일은 다음 경로 내에 위치합니다.
> 엔진설치경로\엔진버전\Engine\Config
> 
> UE5 Config파일 경로 예시  
> C:\Program Files\Epic Games\UE_5.0\Engine\Config

### 02.1 BaseEditorPerProjectUserSettings.ini

#### 02.1.1 [Developers 폴더](#23-로컬-테스트는-developers-폴더-내에서-해야합니다) 사용 편의를 위한 설정

`Developers` 폴더를 언제나 개인화된 실험실로 사용할 수 있게 보장해주기 위한 설정입니다. 자세한 내용은 [Developers 폴더](#23-로컬-테스트는-developers-폴더-내에서-해야합니다) 항목 참조. 

> `BaseEditorPerProjectUserSettings.ini` 파일 내의 다음 구문 변경
> 
> `Ctrl + F`로 `bSCCAutoAddNewFiles` 검색한 뒤, `True`를 `False`로 변경.  
> `bSCCAutoAddNewFiles=False` 저장

#### 02.1.2 [블루프린트 코딩 표준](#3-블루프린트-코딩-표준) 준수를 위한 설정

엔지니어, 테크니컬 아티스트 등 블루프린트 협업 빈도가 높은 팀원들의 [블루프린트 코딩 표준](#3-블루프린트-코딩-표준) 준수 과정에서의 [혼란](#시작하기-전)을 없애기 위한 설정입니다.  

아티스트, 게임 디자이너 등 주로 만들어진 블루프린트를 사용하는 팀원들은 설정하지 않습니다.
> `BaseEditorPerProjectUserSettings.ini` 파일 내의 다음 구문 변경
> 
> `Ctrl + F`로 `bShowFriendlyNames` 검색한 뒤, `True`를 `False`로 변경.  
> `bShowFriendlyNames=False` 저장

**[⬆ Back to Top](#목차)**

<br>
<br>

## 1. 에셋 명명 규칙

스타일 가이드의 모든 부분이 그렇지만, 에셋 명명 규칙은 반드시 지켜야 합니다.  
명명 규칙에 따라 일관되게 지어진 에셋 이름은 에셋 관리, 검색, 분석, 유지보수를 매우 쉽게 만들어줍니다.

명명 규칙의 큰 틀은 다음과 같이 `_`(밑줄)에 의해 에셋의 종류, 이름 등을 구분합니다.

<br>

### 1.1 에셋명 기본 형식: `접두사_기본에셋명_세부변형_접미사`  

`접두사`와 `접미사`는 에셋 형식에 따라 다음의 [에셋 접두사 & 접미사 테이블](#12-에셋-접두사--접미사-테이블)에 의해 결정됩니다.

모든 에셋들은 기본이 되는 에셋 이름인 `기본에셋명`을 가져야만 합니다. `기본에셋명`은 그 에셋이 속한 그룹의 문맥에 연관되는 짧고 쉬운 이름일수록 좋습니다. 예를 들어 캐릭터의 이름이 `Nina`라면, 모든 Nina 에셋들의 `기본에셋명`이 `Nina`가 되어야 합니다.

`세부변형`은 기본에셋에서 `파생된 다양한 변형의 이름`을 지칭합니다. 예를 들어 `Nina` 캐릭터 에셋에는 다양한 `스킨 변형`이 있을 수 있습니다. Nina 스켈레탈 메시 중 `캐주얼 스타일`의 스킨이 있다면 에셋명은 SKM_Nina_`Casual` 이 됩니다.  
또다른 예로 `레트로 스타일`의 스킨이 있다면, 에셋명은 SKM_Nina_`Retro` 가 됩니다.  

이 스켈레탈 메시에 사용되는 텍스처 에셋명의 좋은 예는 캐주얼 스킨의 경우 `T_Nina_Casual_Top_D`, `T_Nina_Casual_Top_N`, `T_Nina_Casual_Feet_D`, 레트로의 경우 `T_Nina_Retro_Top_D`, `T_Nina_Retro_Bottom_D` 가 좋은 예시가 됩니다.

만약 기본에셋명에서 파생되는 `세부변형`이 특정 이름으로 표현하기에는 애매한 눈에 띄는 특징이 없는 경우, `세부변형` 이름을 숫자로 대신할 수 있습니다. 예를 들어 모델러가 다양한 종류의 암석을 디자인했을 때, 그것들의 변형은 SM_Rock_`01`, SM_Rock_`02`, SM_Rock_`03` 같은 형태가 될 수 있습니다. 또는 다음과 같이 특정 `세부변형` 다음에 `변형숫자`가 올 수도 있습니다. SM_Rock_`Basalt_01`, SM_Rock_`Basalt_02`


#### 1.1의 예시들

##### 기본에셋명 `Nina`의 `CasualOffice`변형 예

| 에셋 유형                      | 에셋명                            |
| ------------------------------ | -------------------------------- |
| 스켈레탈 메시 (캐릭터 상의)      | SKM_Nina_Suit_Shirt               |
| 스켈레탈 메시 (캐릭터 하의)      | SKM_Nina_Suit_Slacks              |
| 머티리얼 (캐릭터 상의)           | M_Nina_Suit_Shirt                 |
| 텍스처 *Diffuse/Albedo*         | T_Nina_Suit_Shirt_D               |
| 텍스처 *Normal*                 | T_Nina_Suit_Shirt_N               |

##### 기본에셋명 `Rock`의 `불특정 변형` 예

| 에셋 유형                                      | 에셋명                            |
| --------------------------------------------- | --------------------------------- |
| 스태틱 메시 (변형1)                            | SM_Rock_01                        |
| 스태틱 메시 (변형2)                            | SM_Rock_02                        |
| 스태틱 메시 (변형3)                            | SM_Rock_03                        |
| 머티리얼 (변형들의 마스터)                     | M_Rock                             |
| 머티리얼 인스턴스 (변형1의 인스턴스)            | MI_Rock_01                         |
| 머티리얼 인스턴스 (눈쌓인 세부변형의 인스턴스)   | MI_Rock_Snow                       |

<br>

### 1.2 에셋 접두사 & 접미사 테이블

[1.1 에셋명 기본 형식](#11-에셋명-기본-형식-접두사_기본에셋명_세부변형_접미사)의 `접두사`, `접미사` 규칙입니다.  
이 스타일 가이드는 [텍스처](#126-텍스처-textures)를 제외한 에셋유형에는 가능한 한 접미사를 사용하지 않습니다.


#### 1.2.1 흔히 사용되는 에셋

| 에셋 유형          | 접두사   | 접미사  | Notes                            |
| ----------------- | -------- | ------ | -------------------------------- |
| 레벨              |          |         | `Maps` 폴더 안에 있어야 한다.      |
| 블루프린트         | BP_      |         |                                  |
| 머티리얼           | M_       |         |                                  |
| 머티리얼 인스턴스   | MI_      |         |                                  |
| 스태틱 메시        | SM_      |         |                                  |
| 스켈레탈 메시      | SKM_     |         |                                  |
| 텍스처            | T_       | _?      | 접미사 디테일은 [텍스처 (Textures)](#126-텍스처-textures) 항목을 봐주세요.    |
| 나이아가라 시스템  | NS_      |         |                                  |
| 위젯 블루프린트    | WBP_     |         |                                  |


#### 1.2.2 애니메이션 (Animations)

| 에셋 유형                       | 접두사     | 접미사     | Notes                            |
| ------------------------------ | ---------- | ---------- | -------------------------------- |
| 에임 오프셋                     | AO_        |            |                                  |
| 에임 오프셋 1D                  | AO_        |            |                                  |
| 애니메이션 블루프린트            | ABP_       |            |                                  |
| 애니메이션 컴포짓               | AC_        |            |                                  |
| 애니메이션 몽타주               | AM_        |            |                                  |
| 애니메이션 시퀀스               | A_         |            |                                  |
| 블렌드 스페이스                 | BS_        |            |                                  |
| 블렌드 스페이스 1D              | BS_        |            |                                  |
| 레벨 시퀀스                    | LS_         |            |                                  |
| 컨트롤 릭 *Control Rig*        | CR_         |            |                                  |
| IK 릭 *IK Rig*                 | IK_        |            |                                  |
| IK 리타기터 *IK Retargeter*    | RTG_       |            |                                  |
| 스켈레탈 메시 *Skeletal Mesh*  | SKM_       |            |                                  |
| 스켈레톤 *Skeleton*            | SKEL_      |            |                                  |


#### 1.2.3 인공 지능 (Artificial Intelligence)

| 에셋 유형                | 접두사       | 접미사     | Notes                            |
| ----------------------- | ------------ | ---------- | -------------------------------- |
| AI Controller           | AIC_         |            |                                  |
| Behavior Tree           | BT_          |            |                                  |
| Blackboard              | BB_          |            |                                  |
| Decorator               | BTDecorator_ |            |                                  |
| Service                 | BTService_   |            |                                  |
| Task                    | BTTask_      |            |                                  |
| Environment Query       | EQS_         |            |                                  |
| EnvQueryContext         | EQS_         | Context    |                                  |


#### 1.2.4 블루프린트 (Blueprints)

| 에셋 유형                     | 접두사  | 접미사     | Notes                            |
| ---------------------------- | ------- | ---------- | -------------------------------- |
| 블루프린트                    | BP_    |            |                                  |
| 블루프린트 컴포넌트           | BPC_    |            |                                  | 
| 블루프린트 함수 라이브러리    | BPFL_   |            |                                  |
| 블루프린트 인터페이스         | BPI_    |            |                                  |
| 블루프린트 매크로 라이브러리  | BPML_    |            | 가능한 한 사용하지 않는다.         |
| 열거형 *Enumeration*        | E        |            | 접두사 후 밑줄 없음. eg. `ECharacterState` |
| 구조체 *Structure*          | S        |            | 접두사 후 밑줄 없음.               |
| 위젯 블루프린트              | WBP_     |            |                                  |
| 게임플레이 어빌리티          | GA_      |            |                                  |


#### 1.2.5 머티리얼 (Materials)

| 에셋 유형                               | 접두사     | 접미사     | Notes                            |
| -------------------------------------- | ---------- | ---------- | -------------------------------- |
| 머티리얼                                | M_         |            |                                  |
| 머티리얼 (포스트 프로세스)                | M_PP_     |            |                                  |
| 머티리얼 (데칼)                          | M_Decal_  |            |                                  |
| 머티리얼 인스턴스                        | MI_       |            |                                  |
| 머티리얼 인스턴스 (포스트 프로세스)       | MI_PP_    |            |                                  |
| 머티리얼 인스턴스 (데칼)                 | MI_Decal_ |            |                                  |
| 머티리얼 함수                           | MF_       |            |                                  |
| 머티리얼 파라미터 컬렉션                 | MPC_      |            |                                  |
| 서브서피스 프로파일 *Subsurface Profile* | SSP_      |            |                                  |
| 피직스 머티리얼                          | PM_       |            |                                  |


#### 1.2.6 텍스처 (Textures)

| 에셋 유형                        | 접두사     | 접미사     | Notes                            |
| ------------------------------- | ---------- | ---------- | -------------------------------- |
| 텍스처                           | T_        |            |                                  |
| - Diffuse/Albedo/Base Color     | T_         | _D         |                                  |
| - Normal                        | T_         | _N         |                                  |
| - Roughness                     | T_         | _R         |                                  |
| - Alpha/Opacity                 | T_         | _A         |                                  |
| - Mask                          | T_         | _A         | *똑같이 Opacity 채널에 들어가므로 Alpha/Opacity와 동일합니다.*  |
| - Ambient Occlusion             | T_         | _O         |                                  |
| - Bump                          | T_         | _B         |                                  |
| - Emissive                      | T_         | _E         |                                  |
| - Specular                      | T_         | _S         |                                  |
| - Metallic                      | T_         | _M         |                                  |
| - RGB채널에 패킹된 텍스처         | T_         | _*         | 아래의 [패킹된 텍스처 (Texture Packing)](#1261-패킹된-텍스처-texture-packing)를 참고해주세요. |
| 텍스처 큐브 *Texture Cube*       | TC_        |            |                                  |
| 미디어 텍스처 *Media Texture*    | MT_        |            |                                  |
| 렌더 타깃 *Render Target*        | RT_        |            |                                  |
| 큐브 렌더 타깃                    | RTC_       |            |                                  |


##### 1.2.6.1 패킹된 텍스처 (Texture Packing)

`Roughness`, `Ambient Occlusion`, `Metallic` 등 여러 개의 맵을 RGB채널에 각각 할당해 하나의 텍스처로 패킹하는 것이 일반적입니다. 패킹된 텍스처의 접미사는 RGB 채널에 할당된 맵의 순서를 따릅니다.  
예를 들어, `Emissive`, `Roughness`, `Ambient Occlusion` 맵을 각각 `Red`, `Green`, `Blue` 채널에 할당한 경우, `접미사`는 RGB에 할당된 순서에 따라 `_ERO`가 됩니다.

> RGBA 4채널 패킹은 추천하지 않습니다.  
> 기본 텍스처 압축 포맷이 알파채널 압축을 지원하지 않아, 4채널 압축을 위한 추가적인 연산이 필요해지기 때문입니다. 


#### 1.2.7 기타 (Miscellaneous)

| 에셋 유형                   | 접두사     | 접미사     | Notes                            |
| -------------------------- | ---------- | ---------- | -------------------------------- |
| 데이터 에셋                 | DA_        |            |                                  |
| 데이터 테이블               | DT_        |            |                                  |
| 플롯 커브                   | CV_Float_  |            |                                  |
| 벡터 커브                   | CV_Vector_ |            |                                  |
| 컬러 커브                   | CV_Color_  |            |                                  |
| 커브 테이블                 | CV_Table_  |            |                                  |
| 벡터 필드                   | VF_        |            |                                  |
| HLOD 레이어                 | HLODLayer_ |            |                                  |
| 그룸 *Groom*                | Groom_     |            |                                  |


#### 1.2.8 페이퍼 2D (Paper 2D)

| 에셋 유형              | 접두사     | 접미사     | Notes                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| Paper Flipbook          | PFB_       |            |                                  |
| Sprite                  | SPR_       |            |                                  |
| Sprite Atlas Group      | SPRG_      |            |                                  |
| Tile Map                | TM_        |            |                                  |
| Tile Set                | TS_        |            |                                  |


#### 1.2.9 피직스 (Physics)

| 에셋 유형              | 접두사     | 접미사     | Notes                            |
| --------------------- | ---------- | ---------- | -------------------------------- |
| 피직스 머티리얼        | PM_        |            |                                  |
| 피직스 에셋            | PA_        |            |                                  |
| 지오메트리 컬렉션       | GC_        |            |                                  |
| 지오메트리 컬렉션 캐시  | GC_        | _Cache     |                                  |
| 카오스 솔버            | Solver_    |            |                                  |
| 카오스 캐시 컬렉션      | Chaos_     | _Cache     |                                  |


#### 1.2.10 사운드 (Sounds)

| 에셋 유형              | 접두사     | 접미사     | Notes                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| Dialogue Voice          | DV_        |            |                                  |
| Dialogue Wave           | DW_        |            |                                  |
| Reverb Effect           | Reverb_    |            |                                  |
| Sound Attenuation       | ATT_       |            |                                  |
| Sound Class             |            |            | No prefix/suffix. Should be put in a folder called SoundClasses |
| Sound Concurrency       |            | _SC        | Should be named after a SoundClass |
| Sound Cue               | A_         | _Cue       |                                  |
| Sound Mix               | Mix_       |            |                                  |
| Sound Wave              | A_         |            |                                  |
| 메타 사운드              | MS_        |            |                                  |
| 메타 사운드 소스         | MSS_       |            |                                  |
| 컨트롤 버스              | CB_        |            |                                  |
| 컨트롤 버스 믹스         | CBM_       |            |                                  |


#### 1.2.11 유저 인터페이스 (User Interface)

| 에셋 유형                | 접두사     | 접미사     | Notes                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| Font                    | Font_      |            |                                  |
| 위젯 블루프린트          | WBP_       |            |                                  |


#### 1.2.12 FX

| 에셋 유형                        | 접두사       | 접미사     | Notes                            |
| ------------------------------- | ------------ | ---------- | -------------------------------- |
| 나이아가라 시스템                | NS_          |            |                                  |
| 나이아가라 모듈                 | NM_           |            |                                  |
| Niagara Dynamic Input Script   | NM_           |            |                                  |
| 나이아가라 이미터                | NE_          |            |                                  |
| 나이아가라 이펙트 타입           | EffectType_  |            |                                  |
| 나이아가라 파라미터 컬렉션       | NPC_         |            |                                  |
| - 인스턴스                      | NPCI_        |            |                                  |


#### 1.2.13 미디어 (Media)

| 에셋 유형                | 접두사       | 접미사      | Notes                            |
| ----------------------- | ------------ | ---------- | -------------------------------- |
| File Media Source       | MS_File_     |            |                                  |
| Img Media Source        | MS_Img_      |            |                                  |
| Stream Media Source     | MS_Stream_   |            |                                  |
| Media Player            | MP_          |            |                                  |
| Media Texture           | MT_          |            |                                  |


**[⬆ Back to Top](#목차)**

<br>
<br>

## 2. Content 폴더 디렉터리 구조

에셋 명명 규칙과 마찬가지로, 프로젝트 디렉터리 구조 스타일 역시 반드시 지켜주셔야 합니다.  
에셋 이름과 Content 디렉터리 구조는 서로 연관이 깊으며, 둘 중 하나를 위반한다면 불필요한 혼란이 생기게 됩니다.  

<br>

### 2.0 Content 폴더 디렉터리 구조 예제

프로젝트 이름 `MySampleProject`의 `Content`폴더 디렉터리 구조 예제
<pre>
|-- Content
    |-- <a href="#22-최상위-폴더-규칙">MySampleProject</a>
        |-- <a href="#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오">3D_Assets</a>
            |-- Building
                |-- Balcony
                |-- Wall
            |-- Nature
                |-- Rock
                |-- Tree
            |-- Props
                |-- OldWoodenBench
            |-- OldSchool
        |-- <a href="#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오">3D_Plants</a>
            |-- Desert
                |-- Cactus
                |-- DesertYellowHead
            |-- Arctic
                |-- Moss
        |-- <a href="#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오">Decals</a>
            |-- Concrete
            |-- Metal
        |-- <a href="#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오">Surfaces</a>
            |-- Asphalt
            |-- Fabric
        |-- <a href="#271-characters-이하-폴더에는-적용하지-않음">Characters</a>
            |-- <a href="#28-여러-에셋과-공유되는-에셋들은-common-폴더-내에-위치합니다">Common</a>
                |-- Animations
                |-- Audio
            |-- Nina
                |-- Animations
                |-- Blueprints
                |-- Meshes
                |-- Materials
                |-- Textures
            |-- Abo
                |-- Animations
                |-- Blueprints
                |-- Meshes
                |-- Materials
                |-- Textures
        |-- <a href="#25-프로젝트에-핵심적인-블루프린트-및-기타-에셋은-core-폴더-내에-위치합니다">Core</a>
            |-- Characters
            |-- Engine
            |-- GameModes
            |-- Interactables
            |-- Weapons
        |-- Effects
            |-- Electrical
            |-- Fire
            |-- Weather
        |-- Blueprints
        |-- <a href="#24-모든-레벨-에셋은-maps-폴더-내에-위치해야-합니다">Maps</a>
            |-- Campaign1
            |-- Campaign2
        |-- <a href="#29-materiallibrary">MaterialLibrary</a>
            |-- Debug
            |-- Functions
            |-- Textures
            |-- Utility
        |-- GUI
    |-- <a href="#223-최상위-폴더-규칙을-준수하는-샘플-템플릿-마켓플레이스-콘텐츠는-폴더-구조를-수정하지-않습니다">Megascans</a>
    |-- <a href="#223-최상위-폴더-규칙을-준수하는-샘플-템플릿-마켓플레이스-콘텐츠는-폴더-구조를-수정하지-않습니다">StarterContent</a>
    |-- <a href="#223-최상위-폴더-규칙을-준수하는-샘플-템플릿-마켓플레이스-콘텐츠는-폴더-구조를-수정하지-않습니다">ThirdPerson</a>
</pre>

#### 2.0.1 예제의 폴더들에 대한 설명

##### 일반
| 폴더 이름          | Notes                            |
| ----------------- | -------------------------------- |
| MySampleProject   | [최상위 폴더 규칙](#22-최상위-폴더-규칙)에 따라 생성된 프로젝트의 최상위 폴더         |
| Core              | 프로젝트에 핵심 기능을 하는 에셋들이 모인 폴더. 자세한 내용은 [Core](#25-프로젝트에-핵심적인-블루프린트-및-기타-에셋은-core-폴더-내에-위치합니다) 참조.           |
| Blueprints        | 프로젝트에 핵심적이지는 않은 블루프린트 에셋이 모인 폴더           |
| Maps              | Level 에셋 폴더           |
| MaterialLibrary   | 프로젝트 공용 마스터 머티리얼, 함수, 텍스처 등이 모인 폴더. 자세한 내용은 [MaterialLibrary](#29-materiallibrary) 참조.           |
| GUI               | 위젯 블루프린트, 미디어소스 등 유저 UI/UX 에셋들이 모인 폴더           |

##### 3D 에셋, 재질 관련
| 폴더 이름          | Notes                            |
| ----------------- | -------------------------------- |
| 3D_Assets         | 구조물, 소품, 장식, 환경요소 등의 에셋들이 위치한다. 단순한 스켈레탈 메시 에셋들도 포함된다. |
| 3D_Plants         | 폴리지(Foliage) 기능에 사용될 꽃, 풀, 잡초와 같은 작은 식생 에셋들이 위치한다. |
| Decals            | 데칼에 사용되는 머티리얼, 텍스처 에셋들이 위치한다. |
| Surfaces          | 표면 재질에 사용되는 머티리얼, 텍스처 에셋들이 위치한다. 마스크 같은 맵에 의해 특정 3D 에셋에 종속되지 않고 머티리얼 레이어, 랜드스케이프, 버텍스 페인팅 등에 사용되는 재질들이 속한다. |

위의 `3D_Assets`, `3D_Plants`, `Decals`, `Surfaces` 폴더들은 3D 에셋, 재질, 데칼 등 개체화된 아트 에셋들이 저장되는 경로입니다.  
가장 말단의 폴더는 개체화된 아트 에셋의 [기본에셋명](#11-에셋명-기본-형식-접두사_기본에셋명_세부변형_접미사)이며, 개체화된 에셋들을 아우르는 상위 테마 폴더를 가질 수 있습니다. 예를 들어 사막의 식물 `Cactus`, `DesertYellowHead` 개체의 폴더는 `Content\ProjectName\3D_Plants\Desert\` 이하 경로에 모여있습니다.  

만약 전체가 모여 하나의 컬렉션, 테마를 이루는 개체 집단이 있을 경우, 테마 이름의 폴더만 두고 그 하위에 개체별 폴더는 따로 두지 않습니다. `OldSchool` 테마가 있을 경우, `책상`, `의자`, `교탁`, `깨진 창문` 등 테마에 속하는 모든 개체는 `Content\ProjectName\3D_Assets\OldSchool` 경로에 별도의 개체폴더 없이 모든 리소스를 모아둡니다. 

개체폴더 이하에 `Meshes`, `Textures`, `Materials`, `Blueprints` 폴더는 생성하지 않습니다. 자세한 내용은 [2.7](#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오) 항목을 참고해주세요.

##### 캐릭터 관련
| 폴더 이름           | Notes                                            |
| ------------------ | ------------------------------------------------ |
| Characters         | 본 구조를 가지면서 캐릭터로서 사용되는 에셋들을 가진다. *본 구조를 가졌으나 캐릭터로 사용되지 않는 단순한 에셋들은 `3D_Assets` 경로에 포함된다.* |
| Common         | 여러 캐릭터에 공유될 수 있는 에셋들을 가진다. 자세한 내용은 [2.8](#28-여러-에셋과-공유되는-에셋들은-common-폴더-내에-위치합니다) 항목 참조. |

캐릭터 폴더들은 [2.7](#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오)의 예외로 적용됩니다.  
`Characters` 폴더 이하에는 구체적인 개별 캐릭터 폴더들이 존재합니다. 각각의 캐릭터 폴더는 캐릭터에 사용되는 `Blueprints`, `Meshes`, `Materials`, `Textures` 등 `에셋유형` 폴더를 하위 폴더로 가집니다. 자세한 내용은 [2.7.1](#271-characters-이하-폴더에는-적용하지-않음) 항목을 참고해주세요.

##### 기타
이외의 `Megascans`, `StarterContent`, `ThirdPerson` 폴더는 외부에서 이주되어온 [최상위 폴더](#22-최상위-폴더-규칙)로, [2.2.3](#223-최상위-폴더-규칙을-준수하는-샘플-템플릿-마켓플레이스-콘텐츠는-폴더-구조를-수정하지-않습니다)에 따라 Content 폴더 최상위 경로에 그대로 존재합니다.

보다 자세한 설명과 세부 원칙들은 이하의 항목에서 다룹니다.

<br>

### 2.1 폴더명 규칙

Content 폴더 내의 모든 폴더 이름에 적용되는 공통 규칙들입니다.


#### 2.1.1 항상 파스칼 케이스(PascalCase)를 사용할 것

파스칼 케이스는 첫 문자가 대문자로 시작하며, 각 단어의 시작을 대문자로 구분합니다.
`GameModes`, `DesertEagle` 등이 그 예입니다. 자세한 설명은 [파스칼 케이스(PascalCase)](#파스칼-케이스-pascalcase)를 참고해주세요.  
대문자가 연속으로 오는 등 파스칼 케이스를 그대로 적용하기 애매할 경우, 드물게 `_`(밑줄)을 사용할 수 있습니다. (eg. `3D_Assets`)

> Maya 작업자의 경우 Maya 내에서는 [카멜 케이스(camelCase)](#카멜-케이스-camelcase)가 표준 스타일인 경우가 많아 이 스타일을 그대로 언리얼 엔진에 적용하시는 경우가 많습니다.  
> 언리얼 엔진에서는 [파스칼 케이스(PascalCase)](#파스칼-케이스-pascalcase)가 표준임을 유념해주세요.

#### 2.1.2 공백(스페이스바)을 사용하지 말 것

[금지된 문자](#011-금지된-문자)에 따라 폴더 이름에 ` `공백을 사용해선 안됩니다.

#### 2.1.3 영문과 숫자 이외의 문자(특수문자 포함)를 사용하지 말 것

폴더 이름에 허용되는 문자는 `A-Z`, `a-z`, `0-9` 뿐입니다. [금지된 문자](#011-금지된-문자)의 허용된 문자 항목을 참고해주세요.

<br>

### 2.2 최상위 폴더 규칙

프로젝트의 모든 에셋은 프로젝트 이름을 딴 최상위 폴더 내에 위치해야 합니다. 예를 들어, 프로젝트 이름이 `MySampleProject`이라면 `MySampleProject` 프로젝트를 위해 생성된 모든 에셋은 `Content\MySampleProject\` 내에 위치해야 합니다. 만약 프로젝트 이름이 너무 길거나 프로젝트 이름을 그대로 최상위 폴더명으로 따기에 부적합하다 느낄 경우, 적합한 이름으로 변경할 수 있습니다. 

프로젝트 내의 모든 에셋이 프로젝트의 최상위 폴더에 위치해야하는 것은 아닙니다. 다른 프로젝트에서 이주해오거나 프로젝트에 추가한 마켓플레이스 콘텐츠 등이 있을 경우 이주해온 프로젝트의 에셋들도 `최상위 폴더 규칙`에 따라 각자의 최상위 폴더를 가질 것이므로, 한 프로젝트는 다수의 최상위 폴더를 가질 수 있습니다. 자세한 내용은 [다음](#223-최상위-폴더-규칙을-준수하는-샘플-템플릿-마켓플레이스-콘텐츠는-폴더-구조를-수정하지-않습니다)을 확인해주세요.

> `Developers` 폴더는 프로젝트에 종속된 폴더가 아니므로, 프로젝트별로 구분되지 않습니다. 자세한 내용은 [Developers 폴더](#23-로컬-테스트는-developers-폴더-내에서-해야합니다) 항목을 참고해주세요.

최상위 폴더 규칙에 대한 세부 사항은 다음과 같습니다.

#### 2.2.1 최상위 폴더 바깥에 에셋을 두어선 안됩니다. 

에셋이 프로젝트의 최상위 폴더 바깥에 위치하는 것은 허용되지 않습니다. 구체적인 예시는 다음과 같습니다.  
프로젝트 `MySampleProject` 내의 `T_Rock` 에셋이 최상위 폴더 외의 경로에 잘못 위치한 예시들:  
> `Content\T_Rock.uasset`  
> `Content\Textures\T_Rock.uasset`  
> `Content\Temp\T_Rock.uasset`  
> `Content\Test\T_Rock.uasset`  

최상위 폴더 바깥에 위치한 에셋은 팀원들에게 정리할 필요가 없는 에셋이라는 암시를 주게 되며, 이러한 경로의 존재는 에셋을 정리하지 않는 나쁜 습관을 조장하여 올바른 스타일을 따르는 것을 매우 어렵게 만듭니다.  

최상위 폴더 바깥에 에셋이 위치할 경우 그래야만 하는 명확한 목적이 있어야 합니다. 만약 실험적인 목적을 위한 로컬 테스트 에셋이라면 [Developers 폴더](#23-로컬-테스트는-developers-폴더-내에서-해야합니다) 내에 위치해야 합니다.


#### 2.2.2 최상위 폴더 규칙은 이주 충돌을 감소시켜줍니다.

여러 프로젝트에서 작업이 이루어지면서 다른 모든 프로젝트에 유용하게 사용될 에셋이 있는 경우, 한 프로젝트에서 다른 프로젝트로 에셋 그룹을 `이주(Migrate)`하는 것이 일반적입니다. 콘텐츠 브라우저의 이주 기능을 사용하여 에셋을 다른 프로젝트로 복사하는 경우, 에디터의 종속성 검사에 의해 이와 관련된 에셋 일체가 함께 복사됩니다. 

두 프로젝트 사이에 [최상위 폴더 규칙](#22-최상위-폴더-규칙)이 제대로 지켜지지 않는 경우, 에셋의 이주는 쉽게 문제를 일으키게 됩니다. 구체적인 충돌 예시는 다음과 같습니다. 

##### 2.2.2.1 마스터 머티리얼 이주 충돌 예시

`ProjectA`에서 마스터 머티리얼을 만들었고, 이 머티리얼이 `ProjectB`에도 유용하다 판단해 이주하는 상황을 가정합니다. 만약 프로젝트가 [최상위 폴더 규칙](#22-최상위-폴더-규칙)을 지키지 않는 경우, 마스터 머티리얼은 `Content\MaterialLibrary\M_Master`와 같은 경로에 위치할 확률이 높아집니다.

문제는 `ProjectB`도 최상위 경로 규칙을 지키지 않으며 동일한 경로에 이미 자체적인 마스터 머티리얼이 있을 경우 발생합니다. `ProjectB`의 아티스트들은 지시받은 대로 `Content\MaterialLibrary\M_Mater`의 인스턴스를 생성해 여러 에셋에 이미 이를 적용해두었습니다. 이 상태에서 `ProjectA`의 `M_Master`가 이주되면 기존의 `M_Master`를 덮어씌우며 의도치 않게 기존의 모든 에셋의 룩을 변경하는 결과가 발생하게 됩니다.

이러한 충돌 문제는 이주를 실행하는 당사자가 아티스트라면 미리 예측하기 어려우며, 충돌이 발생한 후에도 문제가 발생한 이유를 쉽게 발견하지 못할 수 있습니다. 스태틱 메시를 이주하는 아티스트는 종속성에 의해 `Content\MaterialLibrary\M_Mater` 에셋이 함께 이주되는 것을 미리 파악하지 못할 수 있으며, 일반적으로 아티스트는 마스터 머티리얼 개발에 익숙한 사람이 아닐 가능성이 높기 때문에 잘못된 덮어씌움으로 기존 에셋에도 문제가 발생했다는 사실을 파악하지 못할 수 있습니다. 

이처럼 [최상위 폴더 규칙](#22-최상위-폴더-규칙)이 지켜지지 않은 두 프로젝트 사이의 이주는 기존 에셋과의 충돌을 일으킬 확률이 매우 높아집니다. 만일 두 프로젝트가 모두 [최상위 폴더 규칙](#22-최상위-폴더-규칙)을 지키고 있었다면, `ProjectB`로의 이주 결과는 다음과 같이 되며 충돌을 피할 수 있습니다. 
<pre>
|-- Content
    |-- ProjectA
        |-- MaterialLibrary
            |-- M_Master.uasset
    |-- ProjectB
        |-- MaterialLibrary
            |-- M_Master.uasset 
</pre>


이는 에픽이 마켓플레이스 가이드라인에 동일한 규칙을 적용하는 이유입니다.

#### 2.2.3 최상위 폴더 규칙을 준수하는 샘플, 템플릿, 마켓플레이스 콘텐츠는 폴더 구조를 수정하지 않습니다.

[2.2.2](#222-최상위-폴더-규칙은-이주-충돌을-감소시켜줍니다)의 예를 보듯, 마켓플레이스 콘텐츠, 템플릿 등은 [최상위 폴더 규칙](#22-최상위-폴더-규칙)을 준수하기 때문에 이러한 에셋의 추가는 프로젝트에 방해가 되지 않습니다.

하지만 마켓플레이스 콘텐츠가 언제나 [최상위 폴더 규칙](#22-최상위-폴더-규칙)을 준수한다고 신뢰할 수는 없습니다. 마켓플레이스 콘텐츠를 본 프로젝트에 추가하기 전 반드시 테스트 프로젝트에 먼저 추가해본 뒤, 규칙을 준수하는 경우에만 본 프로젝트로 이주합니다. 그렇지 않을 경우 규칙에 따라 정리한 뒤 이주합니다.

[최상위 폴더 규칙](#22-최상위-폴더-규칙)을 준수하는 패키지를 올바르게 프로젝트에 추가한 뒤에는 이주된 상태 그대로 별도의 최상위 폴더에 둡니다. 추가한 패키지의 폴더 구조를 변경하거나 기존 프로젝트의 최상위 폴더에 병합하는 일은 해당 패키지가 업데이트되거나 패키지에서 추가로 이주할 에셋이 생길 경우 중복된 에셋을 만들거나 이주 충돌 가능성을 높입니다. 이주해온 패키지에 일부 변형을 주고 싶은 경우, `Content\이주 패키지의 최상위폴더\Modified` 폴더를 만들어 패키지에서 변경된 사항은 `Modified` 폴더에 모아 추가 이주로 인한 충돌 가능성을 줄여야 합니다.

추가한 패키지의 최상위 폴더 구조를 변경하는 경우는 해당 패키지를 프로젝트에 완전히 병합하려는 경우에 한합니다.


#### 2.2.4 다른 프로젝트로 자주 이주될 수 있는 에셋 그룹은 별도의 최상위 폴더를 가져야 합니다.

만약 프로젝트의 일부 작업사항을 다른 프로젝트로 이주할 계획이 있거나, 빈번하게 다른 프로젝트와 공유되는 작업이 있을 경우 이러한 작업들을 모아 별도의 최상위 폴더에 두는 것을 고려해야 합니다. 이 결정은 주로 프로그래머 또는 마스터 머티리얼 등을 제작하는 테크니컬 아티스트가 내리게 됩니다.  

자주 이주되는 에셋 그룹을 별도의 최상위 폴더에 두는 것은 이 그룹을 메인 프로젝트와 분리된 별도의 모듈처럼 만들어, 다른 프로젝트로의 이주를 쉽게 만들어줍니다. 분리된 최상위 폴더의 에셋들은 본 프로젝트의 에셋을 참조해서는 안됩니다. 본 프로젝트에서 분리된 에셋들이 다시 본 프로젝트의 에셋을 참조할 경우, 분리된 최상위 폴더의 이주는 본 프로젝트의 에셋까지 함께 이주해버리며 간편한 이주를 불가능하게 만듭니다. 

프로젝트 최상위 폴더에서 분리된 최상위 폴더로의 방향으로만 참조가 이루어져야 모듈화된 에셋 그룹이라는 장점이 보장됩니다. 이렇게 분리된 최상위 폴더는 개념상 모듈화된 에셋 그룹이 되어, 에셋을 변경해 다른 프로젝트에 패치로서 이주하거나, 다른 프로젝트로부터 다시 이주해와 패치를 적용하는 일을 분리된 최상위 폴더의 이주만으로 간단히 가능하게 만들어주며 본 프로젝트에 영향을 최소화해줍니다.

<br>

### 2.3 로컬 테스트는 `Developers` 폴더 내에서 해야합니다.

팀원들은 프로젝트에 영향을 끼치지 않으면서도 자유롭게 이런저런 실험을 해보기를 원할 수 있습니다. 다른 팀원과 공유될 필요가 전혀 없는 완전히 실험적인 에셋을 `소스컨트롤(VLAST의 경우 PlasticSCM)`에 추가하는 행위는 프로젝트의 디렉터리 구조를 혼잡하게 만들며, 팀원이 실수로 완전히 실험적인 에셋을 사용할 위험까지 생기게 됩니다. 이러한 실험적인 에셋을 소스컨트롤에 제출한 채로 장기간 방치할 경우, 그것의 제거는 광범위한 문제를 일으킬 수도 있습니다.

소스컨트롤에 영향을 끼치지 않으며 마음껏 테스트해보기 위해 사본 프로젝트를 만든 뒤 사본 프로젝트에 테스트 환경을 구축할 수도 있지만, 보다 나은 방법은 `Developers` 폴더를 이용하는 것입니다.

`Developers` 폴더는 로컬에만 존재하는 완전히 실험적인 에셋이 저장되는 공간입니다. `Developers` 폴더 내의 환경은 프로젝트 소스컨트롤과 분리된 완전히 개인화된 실험실 같은 것입니다. 따라서 소스컨트롤은 `Developers` 폴더 내의 어떠한 에셋도 관리하지 않으며, 실수 또는 모종의 이유로 `Developers` 폴더 내의 에셋이 체크인되었다 하더라도 팀원들은 `Developers` 폴더 내의 어떠한 에셋도 참조해서는 안됩니다. `Developers` 폴더에서 충분한 실험이 이루어져 프로젝트 폴더로 이동해도 되겠다는 판단이 설 경우, 해당 에셋을 올바른 경로로 이동시킨 뒤 리디렉터를 고쳐주기만 하면 됩니다.

`Developers` 폴더는 콘텐츠 브라우저에서 기본적으로 숨겨져 있습니다. 콘텐츠 브라우저 세팅의 `개발자 콘텐츠 표시(Show Developers Content)` 항목을 체크해야 콘텐츠 브라우저에 노출됩니다.  

폴더 이름이 개발자 폴더지만, `Developers` 폴더는 `아티스트도 유용하게 사용`할 수 있습니다. 3D 모델러의 경우 새로 만든 에셋을 먼저 `Developers` 폴더에 임포트한 뒤 메시의 트라이앵글이나 노멀에 문제가 없음을 확인한 후 올바른 경로로 이동시킬 수 있습니다. 리거의 경우 `Developers` 폴더에서 먼저 새로운 캐릭터의 웨이트, 모프타깃, 본 방향 등이 올바르게 적용되는지 확인한 후 올바른 경로로 이동시킬 수 있습니다.  

`Developers` 폴더 내의 모든 에셋은 `소스컨트롤(PlasticSCM)`의 `ignore.conf` 설정에 의해 무시되도록 설정되어있습니다. 하지만 에디터 개인설정에서 `변경 시 새 파일 추가(Add New Files when Modified)` 옵션이 켜져있을 경우, `변경 시 새 파일 추가` 기능이 `ignore.conf` 규칙을 무시한 채 `Developers` 경로에 추가된 에셋을 체크인 대기 항목에 올려버리며 소스컨트롤에 잘못 제출하는 실수를 유발합니다. 이 기능을 꺼두었다 하더라도 `Saved` 폴더를 삭제하면 에디터 개인설정이 엔진 기본설정으로 초기화되며 다시 켜지게 됩니다.  
때문에 `Developers` 폴더를 완전히 개인화된 실험실로 사용하기 위해서는 [Developers 폴더 사용 편의를 위한 설정](#0221-developers-폴더-사용-편의를-위한-설정)이 되어있어야 합니다.

`Developers` 폴더를 적극적으로 활용하세요. 충분한 테스트를 거친 에셋들만 소스컨트롤에는 체크인하게 되며 팀의 생산성이 높아지게 됩니다.  

<br>

### 2.4 모든 레벨 에셋은 `Maps` 폴더 내에 위치해야 합니다.

<br>

### 2.5 프로젝트에 핵심적인 블루프린트 및 기타 에셋은 `Core` 폴더 내에 위치합니다.

프로젝트의 근본을 이루는 매우 중요한 에셋에는 `Content\Project\Core` 경로를 사용하십시오. 예를 들어 프로젝트의 기본이 되는 `GameMode`, `Character`, `PlayerController`, `GameState`, `PlayerState`와 이와 관련된 블루프린트 등이 여기에 위치할 수 있습니다.

`Core` 폴더를 사용하면 팀원들에게 이 안의 에셋은 수정해선 안된다는 사실을 명확히 암시할 수 있습니다. 아티스트들이 흔히 접근하는 경로에는 `Core` 블루프린트로부터 파생된 자식 블루프린트들이 위치하게 되며, 아티스트들은 `Core` 블루프린트를 직접 다루는 대신 그 자식을 다루며 게임 플레이를 제작하게 됩니다. 이 가이드에 따라 아티스트들은 `Core` 폴더에 접근할 이유가 거의 사라지게 됩니다.

예를 들어, 프로젝트에는 레벨에 배치할 수 있는 기본 아이템 클래스가 존재할 수 있으며, 그 기본 동작을 정의한 클래스가 `Content\Project\Core\Item`에 위치할 수 있습니다. 게임 디자이너가 흔히 접근하는 경로에는 이 부모 블루프린트로부터 파생된 자식 블루프린트가 존재하며, 게임 디자이너는 자유롭게 이 파생 블루프린트를 조정하며 게임 플레이를 구성할 수 있습니다. 이러한 분리는 게임 디자이너가 `Core`에 정의된 부모 블루프린트를 직접 수정해 프로젝트 전체에 문제를 일으키는 일을 방지합니다.


<br>

### 2.6 이름이 `Assets`인 폴더를 만들지 마십시오.

`Assets` 폴더가 암묵적으로 3D 에셋들에 사용되는 경로임을 알지만, 3D 에셋 외의 모든 에셋들도 `Assets`이기에 이 스타일 가이드에서는 권장하지 않습니다.  
이 스타일 가이드는 메가스캔의 스타일에 영향을 받아 3D 에셋들에는 `3D_Assets` 경로를 사용합니다.

<br>

### 2.7 이름이 `Meshes`, `Textures`, `Materials`인 `에셋유형` 폴더를 만들지 마십시오.

이 규칙은 `3D_Assets`, `3D_Plants`, `Surfaces`, `Decals` 등 폴더 내의 에셋이 주로 `스태틱 메시`, `머티리얼`, `텍스처` 유형인 폴더들에 강제됩니다.  
예외 상황은 [`Characters` 폴더 이하에는 적용하지 않음](#271-characters-이하-폴더에는-적용하지-않음)를 확인해주세요.

모든 에셋 이름은 이미 접두사에 자신의 에셋 유형을 담고있습니다. `Meshes`, `Textures`, `Materials`와 같은 에셋 유형 폴더는 중복된 정보를 제공할 뿐입니다.

잘 정리된 에셋 이름은 이미 접두사에 의해 유형별로 잘 정돈되어 폴더에 추가로 정리하는 것의 이득이 적습니다. 만일 특정 유형의 에셋만 모아서 보고 싶다면, `콘텐츠 브라우저`의 `필터 기능`을 이용하는 것으로 에셋유형 폴더를 간단히 대체할 수 있습니다. 스태틱 메시만을 보고싶다면, `Meshes` 폴더에 정리하는 대신 단지 `스태틱 메시 필터`를 켜기만 하면 됩니다. 머티리얼과 텍스처만 보고싶다면, `Materials`, `Textures` 폴더에 정리하는 대신 `머티리얼과 텍스처 필터`를 켜기만 하면 됩니다. 

이 규칙은 불필요하게 깊어진 폴더 구조를 간소화해 폴더 탐색 피로도를 줄여줍니다. 또한 이러한 유형의 에셋을 자주 임포트해야하는 아티스트들이 `Materials` 폴더에 텍스처를 넣는 등의 실수도 방지해줍니다. 전체 파일경로 길이를 줄여주며 `쿠킹 파일 경로 길이` 제한에 걸리는 일도 줄여줍니다.

이 규칙의 핵심은 3D 에셋 폴더들을 에셋유형 단위로 해체하지 않고 실제로 월드에 배치될 개체 단위로 `폴더 자체를 개체화`하는 데 있습니다.

<pre>
|-- Content
    |-- ProjectName
      |-- 3D_Assets
          |-- Building
              |-- Balcony
              |-- Wall
          |-- Nature
              |-- Rock
              |-- Tree
          |-- Props
              |-- Book
              |-- OldWoodenBench
      |-- 3D_Plants
          |-- Desert
              |-- Cactus
              |-- DesertYellowHead
          |-- Arctic
              |-- Moss
      |-- Decals
          |-- Concrete
          |-- Blood
          |-- Metal
      |-- Surfaces
          |-- Grass
          |-- Asphalt
          |-- Fabric
</pre>

다음과 같이 실제로 배치될 개체 단위로 잘 정리된 폴더구조는 아티스트가 `Meshes`와 같은 불필요한 에셋유형 정보가 아닌, 실제로 찾으려는 `개체이름`에 집중해 폴더를 탐색할 수 있게 해줍니다. 개체이름의 폴더 안에는 그 개체에 필요한 모든 `스태틱 메시`, `머티리얼`, `텍스처` 등이 포함되어있으며, 아티스트는 콘텐츠 브라우저의 필터링 시스템을 활용해 구체적인 에셋 유형을 찾으면 됩니다.


#### 2.7.1 `Characters` 이하 폴더에는 적용하지 않음.

캐릭터 에셋은 개체폴더 내에 `스켈레탈 메시`, `머티리얼`, `텍스처` 외에도 `애니메이션 블루프린트`, `애니메이션 시퀀스`, `블루프린트`, `애니메이션 몽타주`, `피직스 에셋`, `사운드` 등 매우 다양한 에셋유형을 가지게 되며, 단순한 3D 모델이나 재질 에셋과는 달리 체계적으로 구조화됩니다.  

이러한 특징을 가지는 폴더에까지 [2.7](#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오)의 규칙을 적용하는 것은 콘텐츠 브라우저에 5개 이상의 다양한 필터를 준비해두게 만들어 필터 시스템의 전반적인 편의 자체를 해치게 됩니다. 또한 [2.7](#27-이름이-meshes-textures-materials인-에셋유형-폴더를-만들지-마십시오)의 규칙은 캐릭터와 같은 복잡하게 구조화된 폴더에는 적합하지 않습니다.  

따라서, `Characters` 경로 이하의 캐릭터 폴더들은 다음과 같은 관습적인 스타일을 따라 `에셋유형` 폴더를 만들어줍니다. 
<pre>
|-- Content
    |-- ProjectName
      |-- Characters
          |-- Nina
              |-- Audio
              |-- Animations
              |-- Blueprints
              |-- Meshes
              |-- Materials
              |-- Textures
</pre>

<br>

### 2.8 여러 에셋과 공유되는 에셋들은 `Common` 폴더 내에 위치합니다.

다른 개체 에셋들과 쉽게 공유되고 호환되는 특정 에셋 유형들이 있습니다. 가장 일반적인 예는 `애니메이션`과 `오디오` 에셋입니다. 

예를 들어, `애니메이션`의 경우 여러 스켈레톤에 걸쳐 공유되는 애니메이션이 있을 수 있습니다. UE5에서부터는 유사한 본 구조를 지닌 캐릭터 사이에서의 애니메이션 공유가 특히 쉬워졌으므로, 이런 유형의 에셋들에 `Content\Project\Characters\Common\Animations`와 같은 경로를 적용할 수 있습니다.

<br>

### 2.9 `MaterialLibrary`

프로젝트 전체에 걸쳐 광범위하게 사용되는 `마스터 머티리얼`, `머티리얼 함수`, `텍스처` 등은 `Content/Project/MaterialLibrary` 경로에 있어야 합니다.

이 규칙은 아티스트들이 `머티리얼 인스턴스만 사용` 규칙을 따르는 것을 매우 쉽게 만들어줍니다. 프로젝트에 `머티리얼 인스턴스만 사용` 정책을 사용할 경우, 전체적인 룩에 변경이 필요할 때 3D 에셋 각각의 머티리얼을 수정할 필요 없이 마스터 머티리얼 하나만 변경하는 것으로 전체에 변경사항을 적용할 수 있습니다. `머티리얼 인스턴스만 사용` 정책은 생산성을 높이고 유지보수를 쉽게 만들어주며, `MaterialLibrary` 폴더의 사용은 정책을 따르는 것을 쉽게 만들어줍니다. 

`MaterialLibrary`는 순수 머티리얼만으로 구성되지 않습니다. 프로젝트 전체에 사용되는 `텍스처`, `머티리얼 함수`, 또는 이러한 목적을 지닌 셰이더 관련 에셋들은 모두 `MaterialLibrary` 이하에 위치합니다. 예를 들어, 공용 노이즈 텍스처는 `Content\Project\MaterialLibrary\Textures` 경로에 위치하며, 공용 노이즈 함수는 `Content\Project\MaterialLibrary\Functions` 경로에 위치합니다.

모든 테스트 또는 디버깅을 위한 머티리얼은 `MaterialLibrary\Debug` 폴더 내에 있어야 합니다. 이는 프로젝트가 배포용으로 패키징되기 이전에 디버깅을 위한 요소들을 제거하는 것을 쉽게 만들어주며, 참조 오류가 발생할 경우 디버깅을 위한 에셋을 사용하고 있지는 않은지 확인하는 것을 쉽게 만들어줍니다.

<br>

### 2.10 리디렉터, 비어있는 폴더

에셋의 이름 또는 경로 변경은 그 자리에 동일한 이름의 리디렉터 파일을 남기게 됩니다. 이를 인식하지 못하고 다시 리디렉터와 동일한 이름으로 파일을 생성하거나 가져올 경우, 리디렉터로 덮어씌워지며 파일이 사라져 작업사항을 잃어버릴 수 있습니다. 

리디렉터의 제거는 콘텐츠 브라우저에서 폴더를 우클릭한 뒤 `폴더의 리디렉터 고치기(Fix Up Redirectors in Folder)`로 수행할 수 있으며, 에셋의 이름이나 경로를 변경한 후에는 곧바로 리디렉터를 고쳐줘야 합니다.

`Content` 폴더 안에 빈 폴더를 남겨두지 마십시오. 만약 삭제되지 않는 빈 폴더가 있다면, 폴더 내에 리디렉터 파일이 있는 것입니다. `폴더의 리디렉터 고치기` 기능으로 리디렉터를 제거한 뒤 빈 폴더를 삭제해주세요. 리디렉터는 기본적으로 감춰져있으며, 콘텐츠 브라우저 설정을 통해 볼 수 있습니다.

**[⬆ Back to Top](#목차)**

<br>
<br>
<br>
<br>

## 3. 블루프린트 코딩 표준

<br>

### 시작하기 전
`친근한 변수 이름 표시(Show Friendly Name)`를 끄는 것은 블루프린트 코딩 표준 준수 과정에서의 불필요한 혼란을 줄여줍니다. Saved 폴더를 삭제해도 항상 이 설정이 적용되도록 하려면 [블루프린트 코딩 표준 준수를 위한 설정](#0222-블루프린트-코딩-표준-준수를-위한-설정)을 따라 설정해주시면 됩니다.

`친근한 변수 이름 표시`로 인해 발생할 수 있는 혼란은 다음과 같습니다.  

| 변수 이름 원형            | 친근한 변수 이름 표시       | 
| ------------------------ | ------------------------- | 
| bFired                   | Fired                     | 
| PublicVarName            | Public Var Name           | 
| mPrivateVarName          | M Private Var Name        |   
| mbProtectedBoolName      | Mb Protected Bool Name    |  
| SomeNumberWithPascal     | Some Number with Pascal   |  
| Some Number With Space   | Some Number with Space    |  
| Some_Number_With_Snake   | Some Number with Snake    | 

1. 접두사 b-가 자동으로 생략됨
2. 단어의 첫 문자가 대문자로 변경되며 [카멜 케이스](#카멜-케이스-camelcase)와 [파스칼 케이스](#파스칼-케이스-pascalcase)를 구분할 수 없어짐
3. [파스칼 케이스](#파스칼-케이스-pascalcase)의 단어구분 사이에 자동으로 공백이 추가됨
4. 밑줄이 자동으로 공백으로 변환됨
5. 3-4의 문제로 겉보기상 동일한 변수명에 [파스칼 케이스](#파스칼-케이스-pascalcase), [스네이크 케이스](#스네이크-케이스-snake_case), [공백](#011-금지된-문자)이 모두 사용되는 문제 발생  

`친근한 변수 이름 표시`를 끄는 것은 모두가 변수 이름을 원형 그대로 볼 수 있도록 하여 이러한 혼란을 피하게 해줍니다.

<br>

### 3.0 기본 원칙

1. 코드 자체가 문서 역할을 하도록, 가독성을 최우선으로 삼아야 합니다.
2. 컴파일과 런타임 모두에서 단 하나의 경고나 오류도 없어야 합니다.

<br>

### 3.1 컴파일과 런타임

#### 3.1.1 컴파일

모든 블루프린트는 반드시 컴파일 결과에 경고 및 오류가 없어야 합니다. 블루프린트 경고 및 오류는 예기치 못한 동작으로 이어질 수 있으므로 발견 즉시 고쳐야 합니다.

망가진 블루프린트는 잘못된 참조, 예상치 못한 실행결과, 쿠킹 실패, 잦은 재컴파일 등 여러 문제를 일으킵니다. 망가진 블루프린트의 방치는 프로젝트 전체를 망가뜨리므로, 컴파일되지 않는 블루프린트를 소스컨트롤에 제출하지 마십시오.

#### 3.1.2 런타임

런타임이란 게임의 실행 도중을 의미합니다. 컴파일 결과에 경고 및 [오류](#오류)가 없었다 할지라도, 런타임 도중에 문제가 발생할 수도 있습니다. 예를 들어 컴파일할 때는 정상적으로 참조하던 개체가 런타임 도중 Destroy 되었는데 다시 참조하는 경우, 런타임 도중 None 참조 오류가 발생하게 됩니다. 런타임 오류를 발견할 경우 먼저 프로그램 로직 자체에 문제가 있지는 않은지 검증해야 하며, 런타임 도중 언제든 발생할 수 있는 문제라면 [적절한 예외처리](#)가 필요합니다. 

또한 런타임 중에는 프로그램 로직 자체의 결함으로 [버그](#버그)가 발생할 수 있습니다. 런타임 도중 이런 버그가 발생할 경우 즉시 원인을 파악하고 고쳐야합니다. 

경고는 지금 당장 문제를 일으키지는 않기 때문에 가볍게 여겨지고 방치되기 쉽습니다. 방치된 채 누적된 경고는 언젠가 정말 중요한 문제가 발생했을 때 경고 사이에서 정말 중요한 단서를 찾아내는 일을 어렵게 만드므로, 경고도 발견 즉시 고쳐야 합니다.

<br>

### 3.2 변수

[변수와 프로퍼티](#변수variable와-프로퍼티property)는 일반적인 문맥에서 서로 바꿔서 사용할 수 있습니다. 블루프린트에서는 변수 용어 사용이 흔하므로, 이 스타일 가이드에서는 프로퍼티도 모두 변수로 표현합니다. 

#### 3.2.1 변수 이름은 명사여야 합니다.
변수 이름은 그 자체로 명확하게 이해할 수 있는 명사여야 합니다.  
누구나 이해할 수 있도록 충분히 설명적인 명사여야 하며, 지나친 축약을 피해야 합니다.

*[불리언 변수](#324-불리언-변수는-is-can-has-should와-같은-의문형-동사를-가질-수-있습니다)는 동사가 사용될 수 있습니다.*


#### 3.2.2 Public 변수에는 파스칼 케이스를 사용합니다.
기본적으로 모든 변수 이름은 [파스칼 케이스](#파스칼-케이스-pascalcase)를 따릅니다.  
불리언 변수와 Public 이외의 변수에는 특정한 접두사가 붙습니다.

즉, [불리언을 제외한](#323-불리언-변수는-b--접두사를-가집니다) `모든 Public 변수`는 [파스칼 케이스](#파스칼-케이스-pascalcase)를 따릅니다.  

*불리언이 아닌 Public 변수 이름의 예:*
* `Score`
* `Kills`
* `TargetPlayer`
* `Range`
* `PlayerID`


#### 3.2.3 불리언 변수는 접두사 b-를 붙입니다.
모든 `불리언 변수`는 `소문자 b`를 접두사로 가집니다.

예를 들어 사망 상태를 체크하는 변수는 `Dead`에 `b-`를 붙여 `bDead`가 되어야 합니다.

#### 3.2.4 불리언 변수는 Is, Can, Has, Should와 같은 의문형 동사를 가질 수 있습니다.
몇몇 스타일 가이드에서는 불리언 변수에 동사를 사용하는 것은 함수와 혼동을 일으키므로 사용을 금지하고 있습니다. 하지만 예/아니오를 담는 불리언 변수에 접근할 때 그 이름이 의문형인 것은 자연스러우며, 더 나은 가독성을 제공합니다.  

`불리언 변수`에는 `b-` 접두사가 오기 때문에 함수와의 혼동을 피할 수 있고 에픽의 코딩 표준도 불리언 변수에 의문형 동사를 사용하므로, 이 스타일 가이드에서는 불리언 변수에 의문형 동사를 허용합니다.

*다음은 모두 올바른 이름입니다.* 
* `bDead`
* `bIsDead`
* `bHostile`
* `bIsHostile`
* `bAlive`
* `bHasChild`

#### 3.2.5 불리언 변수 이름은 예/아니오로 명확하게 대답할 수 있어야 합니다.

나쁜 예: `bCheckTea`
`bCheckTea`는 `예/아니오`로 명확하게 대답할 수 있는 형태가 아닙니다. `bCheckTea`가 `True`라면 어떤 상태라는 것인지 모호합니다.

좋은 예: `bIsTeaFresh`
`bIsTeaFresh`는 `예/아니오`로 명확하게 대답할 수 있습니다. `bIsTeaFresh`가 `True`라면 차가 신선하다는 것이 명확해집니다.  
불리언 변수는 이처럼 예/아니오로 명확히 대답할 수 있는 이름이어야 합니다.

#### 3.2.6 불리언 변수로 복잡한 상태를 정의하지 마십시오.
불리언 변수는 언제나 변수 하나로 하나의 상태를 온전히 정의할 수 있어야 합니다. 하나의 상태를 온전히 정의하는 데 두 개 이상의 불리언 변수가 필요하다면 `열거형`을 사용하십시오.

예를 들어 캐릭터의 걸음걸이 상태를 정의하는 상황을 가정해보겠습니다. `캐릭터의 걸음걸이`에는 `Walking`, `Running`, `Sprinting` 등 `세 가지 이상의 상태`가 존재할 수 있습니다.
이런 상태를 불리언으로 정의하려면 각각의 상태에 각각의 변수 `bWalking`, `bRunning`, `bSprinting`가 필요하며, 하나의 상태를 정의하기 위해선 다른 모든 상태 변수를 false로 변경해줘야 합니다. 여기에 기어가거나 절뚝거리는 상태가 또다시 추가된다면 로직의 크기에 따라 이 작업은 매우 번거로워질 수 있습니다. 불리언 대신 `열거형`을 사용하면 `PlayerWalkState` 변수 하나로 상태를 정의할 수 있으며, 상태의 추가/제거도 간편해집니다.

#### 3.2.7 private, protected 변수에는 접두사 m-을 붙입니다.

`Public`, `protected`, `private`에 대한 설명은 [접근 제어자](#접근-제어자-access-modifier) 항목을 참고해주세요.

##### 3.2.7.1 private 변수
외부에서 접근해서는 안되며 자식 블루프린트에서도 사용해서는 안되는 게 확실한 변수는 [private](#private)로 설정하십시오. 즉, 현재 클래스 내부에서만 사용할 것이 확실한 변수는 [private](#private)로 설정해야 합니다. 이런 변수를 [private](#private)로 선언하는 것은 변수의 외부 노출을 원천 차단해 게임 디자이너가 블루프린트를 더 안전하게 사용할 수 있도록 해줍니다.

[private](#private) 변수에는 접두사 `m-`을 붙입니다. 모든 변수에 파스칼 케이스만을 사용하면 어떤 변수가 private인지 확인하기 위해서는 매번 변수의 디테일 패널을 확인해야 합니다. `private 변수`에 접두사 `m-`을 붙이면 내부용 변수가 명확히 보이므로 코드 작성이 편리해집니다.

##### 3.2.7.2 protected로 의도된 변수
블루프린트 변수는 [protected](#protected) 접근 제어자를 지원하지 않습니다. 때문에 현재로서는 자식 클래스에서도 사용되거나 잠재적으로 그럴 가능성이 있는 변수는 [Public](#public)으로 열어둘 수밖에 없습니다. 

이처럼 외부에서 접근해서는 안되지만 불가피하게 Public으로 공개된 변수의 문제를 보완하기 위해, `protected로 의도된 변수`에도 접두사 `m-`을 붙이십시오. 이 규칙을 따르면 외부에서 접근하는 사용자는 `m` 접두사가 붙은 변수는 내부용임을 알고 접근하지 않을 것입니다.

이 문제는 [외부 접근자는 언제나 함수를 통해 접근](#3381-외부-접근자는-언제나-함수를-통해-접근) 규칙으로 추가로 보완됩니다.

##### 3.2.7.3 private/protected 변수 이름 예시
즉, `Public이 아닌 모든 변수`에는 `접두사 m-`이 붙습니다. 추가로 `불리언 변수는 접두사 b-가 뒤이어 오게 됩니다.`  

*이 규칙에 따른 예는 다음과 같습니다.*
* `mbFired`  
* `mAge`
* `mName`
* `mProcessState`

#### 3.2.8 변수가 속한 클래스를 고려해 불필요한 의미 중복을 피하십시오.
클래스의 변수들은 이미 그 클래스에 소속되어있음이 명확합니다. 이런 문맥을 고려하지 않은 의미 중복을 피하십시오.

예를 들어 `BP_PlayerCharacter` 개체의 변수에 접근하는 상황을 가정해봅니다.

*나쁜 예:*
* `PlayerScore`
* `PlayerKills`
* `CharacterName`
* `CharacterSkills`
* `CharacterSkin`

호출자 입장에서 이런 변수의 호출은 `BP_PlayerCharacter.CharacterName` 형태가 됩니다. 이미 `PlayerCharacter` 소속임이 명확하므로 `BP_PlayerCharacter.Name` 형태가 되는 것이 더 바람직합니다.

*좋은 예:*
* `Score`
* `Kills`
* `Name`
* `Skills`
* `Skin`


#### 3.2.9 기본 자료형 변수에 자료형 이름을 포함하지 마십시오.
`기본 자료형`에는 `불리언(Bool)`, `정수(Int)`, `실수(Float)`, `열거형(Enum)` 등이 있습니다. `문자열(String)`과 `벡터(Vector)`는 기본 자료형은 아니지만 `블루프린트에서는 기본 자료형처럼 간주`됩니다.  
>	텍스트(Text) 변수는 기본 자료형으로 간주되지 않습니다. 텍스트 변수는 현지화 기능을 숨기고 있습니다. 기본 자료형으로 간주하는 문자열 형태의 변수는 문자열(String) 변수입니다.

*잘못된 예:*
* `ScoreFloat`
* `FloatDamage`
* `DescriptionString`

기본 자료형 이름과 유사하거나 겹치더라도, `NumPosts`, `PostsCount`, `PlayerName`과 같이 문맥상 단지 일반 명사로서 사용된 경우라면 해당하지 않습니다.


#### 3.2.10 배열은 복수형 이름을 가져야 합니다.

*나쁜 예:*
* `TargetList`
* `HatArray`
* `EnemyPlayerArray`

*좋은 예:*
* `Targets`
* `Hats`
* `EnemyPlayers`

#### 3.2.11 구조체의 멤버변수는 모두 파스칼 케이스를 따릅니다.

#### 3.2.12 함수의 매개변수와 지역변수는 모두 카멜 케이스를 따릅니다.

함수를 작성할 때 함수 밖에서 선언된 `클래스 멤버 변수`와 함수 안에서 선언된 `함수 지역 변수`를 가시적으로 구분하기 위한 규칙입니다. 

이 규칙을 따르면 `클래스 멤버 변수`는 모두 [파스칼 케이스](#파스칼-케이스-pascalcase)(Public 외에는 m 접두를 가진)로 표시되고 `함수 지역 변수`는 모두 [카멜 케이스](#카멜-케이스-camelcase)로 표시되어 `어떤 변수가 함수의 시작에서 초기화되는지 인식하기가 편리해집니다.`

#### 3.2.13 런타임 중 변경되어선 안되는 상수
컴파일 단계에서 값을 결정하고 런타임 중 절대 변경되어선 안되는 변수는 `블루프린트 읽기 전용(Blueprint Read Only)`으로 선언해줍니다. 

변수 이름은 [스네이크 표기법](#스네이크-케이스-snake_case)을 따르되, `모든 문자를 대문자`로 표시해 `상수`임을 알립니다.

게임 또는 개체의 초기화 단계에서 값을 읽어와 설정한 뒤 나머지 시간동안 변경되어선 안되는 `상수 성격의 변수`도 같은 이름 규칙을 따릅니다.

*상수, 상수형 변수 이름의 올바른 예:*
* `PLAYER_HP`
* `TARGET_FPS`
* `NUM_PLAYERS`

#### 3.2.14 변수 툴팁
모든 `인스턴스 편집 가능(Instance Editable)`, `스폰시 노출(Exposure on Spawn)` 변수는 툴팁으로 이 변수가 블루프린트 동작에 어떤 영향을 미치는지에 대한 설명을 제공해야 합니다. 

그렇지 않은 변수라도 변수 이름만으로 변수의 목적이 명확히 드러나지 않을 경우 툴팁으로 설명을 보충할 수 있습니다.

#### 3.2.15 슬라이더 및 값 범위

특히 `인스턴스 편집 가능 변수`에서 변수에 허용되지 않는 값이 있을 경우 `슬라이더`로 변수의 값을 제한해줘야 합니다. 예를 들어 절차적으로 울타리를 생성하는 블루프린트의 경우 `FenceCount` 변수에 음수를 입력하는 것은 아무런 의미가 없습니다. 슬라이더 최소값을 0으로 제한해 방지할 수 있습니다. 또한, 지나치게 큰 값을 입력해 에디터를 망가뜨리는 것을 막기 위해 정상범위라 생각하는 최대값도 설정해주면 좋습니다.

특히 슬라이더 최댓값 설정은 해당 변수가 `컨스트럭션 스크립트`에서 사용될 때 중요합니다. 최댓값이 설정되어있지 않으면 드래그 실수로 지나치게 큰 값을 입력하기 쉬우므로, 실수로 인해 에디터 크래시가 나지 않도록 적절한 최댓값을 설정해야 합니다.
	
슬라이더는 값을 드래그할 때 허용되는 범위를 제한할 뿐, 실제 값의 입력을 제한하지는 않습니다. `값 범위`는 실제로 입력될 수 있는 값 자체를 제한하므로, 변수에 허용되는 값 범위가 명확한 경우 정의해줍니다.

#### 3.2.16 카테고리
클래스가 적은 수의 변수만 가지고 있다면 `카테고리`는 필요하지 않습니다.

만약 클래스가 한 눈에 파악하기 어려운 많은 변수를 가진다면, 카테고리로 분류하여 사용자가 변수의 용도를 파악하기 쉽게 해야합니다. `인스턴스 편집 가능 변수`들은 사용자에게 개체의 기본설정을 위한 변수라는 것을 암시하기 위해 `Config` 카테고리에 할당됩니다.

변수 분류의 계층이 깊다면 `|` 를 사용해 하위 카테고리를 만들 수 있습니다. 

*무기 클래스 변수들의 카테고리 예:*

    |-- Config
    |    |-- Animations
    |    |-- Effects
    |    |-- Audio
    |    |-- Recoil
    |    |-- Timings
    |-- Animations
    |-- State
    |-- Visuals

#### 3.2.17 고급 디스플레이 옵션
변수가 수정 가능해야 하기는 하지만 매우 드물게 수정되거나 그 변수에 대해 잘 아는 사람이 아니라면 수정하기를 원치 않을 경우, `고급(Advanced)` 설정의 `고급 디스플레이(Advanced Display)` 옵션으로 변수를 접어 가려줍니다.

#### 3.2.18 기타 `고급(Advanced)` 변수 설정
C++ 수준의 이해도를 가진 작업자가 아니라면 `환경설정 변수(Config Variable)`, `트랜션트(Transient)` 등의 설정은 사용하지 않습니다.

<br>

### 3.3 함수(Functions), 이벤트(Events)

여기서는 함수와 이벤트에 대한 스타일 가이드를 다룹니다. 함수에 적용되는 모든 사항은 별다른 명시가 없는 한 이벤트에도 동일하게 적용됩니다.

#### 3.3.1 함수를 만드는 올바른 태도

`함수의 작성자`는 `누가 이 함수를 호출하게 될지 미리 예측해서는 안됩니다.` 또한, `함수의 호출자`는 `함수 내부를 볼 수가 없다고 가정해야 합니다.` 

작성자가 호출자가 누구인지 예측하고 호출자는 필요할 경우 함수 내부를 볼 수 있다고 가정한 채 함수를 작성하면, 스타일이나 로직이 잘못되어도 이 함수를 쓰는 사람은 함수 내부를 알고있으니 괜찮다는 태도로 방치하기 쉬워집니다.

함수의 작성자는 누가 함수를 호출하게 될지 모르므로, `함수명`, `반환형`, `매개변수`만 보고도 누구나 함수의 기능을 명확히 유추할 수 있도록 만들어야 합니다. 이에 따라 잘 만들어진 함수는 내부 구조를 모르더라도 `함수명`과 `매개변수`, `반환형`만으로 어떤 결과가 보장되는지 명확히 드러나기 때문에, 호출자는 함수 내부를 알 필요 자체가 없어집니다.

#### 3.3.2 함수는 항상 동사로 시작해야 합니다.

`함수는 행동(action)`입니다. 모든 함수는 특정 계산을 수행하거나, 어떤 값을 찾아오거나, 무언가를 폭발시키는 등의 특정 행동을 수행합니다. 때문에 함수 이름은 무언가를 한다는 것을 명확히 드러내기 위해 항상 `동사로 시작`해야 하며, 특별한 이유가 없다면 항상 현재형으로 표현해야 합니다. 

*좋은 예:*
* `ReceiveMessage`
* `SortPlayerItems`
* `GetArmOffset`
* `UpdateTransform`
* `EnableBigHeadMode`
* `IsEnemy`

*나쁜 예:*
* `Dead` - 죽었다는 것인지 죽을 예정이라는 것인지 모호
* `ProcessData` - 프로그램의 모든 것은 데이터입니다. 이 함수 이름은 아무것도 의미하지 않습니다.
* `PlayerState` - 명사이고 어떤 상태를 말하는지도 모호합니다.


#### 3.3.3 순수하게 값을 계산하거나 가져오기 위한 함수는 퓨어(Pure) 함수로 만들어야 합니다.

함수 내부에 주어진 값을 계산만 해 그대로 반환하거나 개체가 가진 값을 그대로 반환하는 등, 개체의 상태나 어떤 변수를 수정하지 않고 순수하게 계산과 반환만 하는 함수는 `퓨어(Pure) 함수`로 만들어야 합니다.

![eg.pure](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/334Pure.png?raw=true)

#### 3.3.4 퓨어함수의 이름은 `Get-` 접두사로 시작해 무엇을 가져오는지 알 수 있게 지어야 합니다.

`퓨어함수`는 무언가를 가져오는 데 사용하기 때문에 `Get- 접두사`로 시작하는 것이 일반적입니다. Get 뒤에 무엇을 가져올 수 있는지 명확히 서술하십시오.

*좋은 예:*
* `GetUnitDirection`
* `GetGameInstance`
* `GetPlayerStamina`  
  

#### 3.3.5 불리언을 반환하는 함수는 질문을 해야합니다.

순수하게 예/아니오 `불리언만을 반환하는 함수`는 `질문을 하는 형태`여야 합니다. 질문형 동사를 가진 불리언 변수에서 b 접두사만 빠진 형태입니다. 이런 함수도 어떤 상태를 가져오는 것이므로 퓨어함수가 됩니다.

*좋은 예:*
* `IsDead`
* `IsOnFire`
* `IsAlive`
* `IsSpeaking`
* `IsVisible`
* `HasWeapon`
* `WasCharging`
* `CanReload`


#### 3.3.6 함수 접근제어자

##### 3.3.6.1 외부 호출이 필요한 함수만 `Public` 함수로 정의하십시오.

함수를 Public으로 공개한다는 것은 그 순간부터 이 함수를 호출하는 수많은 사용자들에 대해 내가 책임을 져야함을 의미합니다. 버그나 기능확장을 위해 함수를 수정하려면, 그 함수를 호출하고 있는 다른 모든 기능들에 문제가 없는지 확인해야하는 책임이 생기게 됩니다. 외부 호출이 필요없는 함수까지 Public으로 지정해 불필요한 책임을 늘려선 안됩니다.

##### 3.3.6.2 그 외의 모든 함수는 `protected`, `private` 함수로 정의하십시오.
불필요한 책임을 늘리지 않기 위해, 내부 기능 처리를 위한 함수들은 `protected, private 함수`로 정의하는 것이 좋습니다.

##### 3.3.6.3 `Public` 함수는 파스칼 케이스, `protected`, `private` 함수는 카멜 케이스를 사용합니다.

[m- 접두 변수 규칙](#327-private-protected-변수에는-접두사-m-을-붙입니다)과 동일한 이유입니다. 내부에서만 호출되는 함수에 [카멜 케이스](#카멜-케이스-camelcase)를 사용하면 블루프린트 작성 중 무엇이 내부용 함수인지 명확히 드러나 가독성이 좋아집니다.


#### 3.3.7 모든 `Public` 함수에는 함수 설명이 있어야 합니다.

[인스턴스 편집 가능 변수에 툴팁 설명을 다는 것](#3214-변수-툴팁)과 같은 이유입니다. [Public 함수](#3361-외부-호출이-필요한-함수만-public-함수로-정의하십시오)는 모두 호출자가 이 함수를 호출하면 무슨 일이 일어나는가에 대해 함수 설명으로 보다 자세한 내용을 제공해야 합니다.  
![eg.description](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/337Description.png?raw=true "Description")


#### 3.3.8 외부 접근이 빈번한 변수에는 `Get`, `Set` 함수를 만드십시오.

가능한 한 외부 접근자가 클래스 내부의 변수에 직접 접근할 일이 없도록, 외부 접근이 빈번한 변수에는 `Get`, `Set` 함수를 제공하십시오. 이러한 패턴은 이미 엔진 기본 클래스의 변수들에 접근할 때도 적용되고 있습니다.

*예시:*  
![eg.engine](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/338Engine.png?raw=true)

이러한 패턴은 `외부 사용자는 언제나 함수를 통해 클래스에 접근하도록 유도`해 잘못된 변수 수정을 막아주는 장점이 있습니다.

예를 들어 어떤 오브젝트의 속도를 추적하는 `VelocitySensor`개체가 있다고 가정해봅시다. 개체의 내부 변수에는 추적 중인 `Velocity`, `Direction`, `Speed`가 있을 것입니다. 이 변수들은 외부에 제공하기 위한 것으로, 값의 계산은 내부에서 이뤄지고 있기 때문에 외부에서 변경해서는 안되는 변수들입니다. 하지만 이 정보들을 외부에 제공하기 위해 변수들을 `Public`으로 열어둔다면 외부 사용자는 이 변수들에 제한 없이 접근이 가능해지며, 사용자는 `Set`이 가능함을 보고 `Speed`의 변경을 시도할 수도 있습니다.

*나쁜 예: 잘못된 방식의 Public 변수 접근*  
![eg.bad](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/338Bad.png?raw=true "Bad")

이런 상황을 방지하기 위해 `private 변수` `mVelocity`, `mDirection`, `mSpeed`를 선언하고 외부에는 `Public 함수` `GetVelocity`를 제공하십시오. `GetVelocity` 함수는 `mVelocity`, `mDirection`, `mSpeed`의 `사본을 반환`할 뿐이며, Set 함수를 제공하지 않는 한 `더 이상 외부에서는 이 변수들을 변경할 수 없게 됩니다.`

*좋은 예: Public Getter 호출을 통한 접근*  
![eg.good](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/338Good_2.png?raw=true "Good")

이런 패턴은 변수를 외부에서 수정할 수는 있지만 값 범위에 제한이 있어야하는 등의 `Set의 선조건`이 필요한 경우에도 유용합니다. 제한 없이 Public 변수로 열어둔다면 외부 접근자는 변수에 직접 어떤 값이든 대입할 수 있게 됩니다. 그보다는 변수는 `private`로 가려둔 뒤 `Set 함수`를 제공하십시오. `Set 함수` 내부에서 매개변수를 유효한 값으로 처리해준 뒤 `private 변수`에 대입해줘 외부 접근이 더 안전해집니다.


#### 3.3.8.1 외부 접근자는 언제나 함수를 통해 접근

[3.3.8](#338-외부-접근이-빈번한-변수에는-get-set-함수를-만드십시오)의 원칙에 따라, 클래스의 외부 접근자는 언제나 함수를 통해 접근하도록 만드십시오. 외부에서의 변수 접근을 완전히 막을 수는 없지만, 최소한 외부 접근이 빈번한 변수들에는 이러한 `Getter`, `Setter` 메서드를 제공한다면 Public 변수의 수를 크게 줄일 수 있습니다. 그 결과 블루프린트에 능하지 않은 아티스트, 게임 디자이너 등은 언제나 제공되는 함수를 호출한다는 가정 하에 클래스를 사용할 수 있게 됩니다.


#### 3.3.9 노드는 특정 기능 단위로 코멘트 블록으로 묶어 무엇을 위한 노드 그룹인지 설명합니다.


#### 3.3.10 모든 함수는 반환 노드(Return Node)를 가지고 있어야 합니다.

모든 함수는 함수가 끝나는 위치에 `반환 노드(Return Node)`를 가지고 있어야 합니다.

`반환 노드`는 `함수가 끝나는 지점을 명시적으로 보여줍니다.` 또한 함수가 끝날 것이라 예상되는 모든 지점에 반환 노드를 추가해두면 컴파일러가 실행 흐름을 디버깅해주게 되어 디버깅이 더 쉬워집니다. 

예를 들어 실행 흐름이 `Sequence`나 `ForLoop` 등에 의해 여러 갈래로 나뉘는 경우, 잘못된 조건체크나 예상보다 빠른 루프 탈출 등으로 인해 실제로는 반환 노드 실행 자체가 논리적으로 불가능한 경우가 생길 수 있습니다. 반환 노드를 추가하지 않으면 오류 없이 컴파일되지만, `모든 예상 종료 지점에 반환 노드를 추가`하면 `컴파일러는 모든 반환 노드가 논리적으로 실행될 수 있는지 검증`하므로 일찍 오류를 발견할 수 있습니다.


#### 3.3.11 Switch 문의 Default 케이스는 항상 추가해야 합니다.

정상적인 실행에서는 `Default 케이스`가 실행될 일이 없다 하더라도, Default 케이스는 항상 추가해줘야 합니다. 만약 논리적으로 Default 케이스가 실행되는 일이 절대 없어야 한다면 Default 케이스에는 [오류 보고](#3313-프로젝트-전용-블루프린트-오류보고-함수) 노드를 넣어줍니다.


#### 3.3.12 두 번 이상 중복되는 노드 그룹은 함수화를 고려해야 합니다.

처음 블루프린트를 짜기 시작할 때는 함수화를 고려하지 마십시오. 일단 노드를 작성해나가다 특정 노드 그룹의 중복이 눈에 띄기 시작한다면, 그 그룹에 대해 함수화를 고려하기 시작하는 게 좋습니다. 

`단순히 노드의 양이 많다해서 함수화를 해서는 안됩니다.` 한 함수 내에 아무리 노드의 양이 많다 할지라도 그 노드들 사이에 반복되는 그룹이 없으며 다른 곳에서도 재사용되지 않는다면, 함수화를 통해 얻을 수 있는 이득은 없습니다. 이처럼 로직의 중복이 없는 단지 긴 일련의 절차에 대해서는 특정 기능 단위로 `노드 접기(Collapse Nodes)` 기능을 사용해 노드를 기능 단위로 접어두는 것이 좋습니다. `노드의 양은 함수화를 고려하는 기준이 아닙니다.`

`특정 노드 그룹의 중복`이 눈에 띄기 시작할 때 함수화를 고려하는 게 좋습니다. 만약 특정 노드 그룹이 한 기능 안에서 여러 곳에서 사용된다면, 중복되는 노드 그룹을 수정하려면 그것들이 사용되는 모든 지점에 찾아가 변경사항을 적용해야 합니다. 만약 이런 상황이 여러 함수, 여러 클래스에 걸쳐 일어난다고 상상해보십시오. 반드시 일부 지점에서는 업데이트를 깜빡하는 실수를 하게 됩니다. `이런 노드를 함수화`를 한다면 `함수 내부를 수정하는 것만으로 함수가 호출되는 모든 지점에 변경사항을 반영`할 수 있게 됩니다. `함수화의 기준은 노드의 중복 여부입니다.`


#### 3.3.13 프로젝트 전용 블루프린트 오류보고 함수

블루프린트의 어서트 기능은 `Functional Test`를 통해서만 사용 가능하게 구현되어 있는데, 이 어서트는 꽤나 불편하게 구현되어있어 적극적으로 활용하기 어렵습니다. 블루프린트에서 간편히 사용할 수 있는 자체 어서트와 오류보고 함수 라이브러리를 만드는 것도 괜찮은 방법입니다. VLAST 프로젝트에는 자체적인 블루프린트 전용 어서트가 있으니 이를 활용해주세요.


#### 3.3.14 함수의 참조형(Reference) 매개변수에는 기본적으로 Null이 들어오지 않는다고 가정합니다.
`Null(None)`이 허용되지 않기 때문에 내부에서 모든 참조형 매개변수가 `유효한지 검증(IsValid)해야한다는 의미가 아닙니다.` 오히려 Null이 절대 들어오지 않을 것이라 가정했기 때문에 `내부에서는 어떤 유효성 검증도 하지 않음을 의미합니다.`   

별다른 표시가 없다면 함수는 기본적으로 Null 매개변수를 예외처리하지 않음을 의미하고, 호출자도 함수가 Null을 제대로 처리해줄 것이라 기대하지 않습니다. 자세한 내용은 [데이터 유효성 검증 원칙](#34-데이터-유효성-검증-원칙)을 참고해주세요. 


#### 3.3.15 함수의 참조형 매개변수가 예외적으로 Null을 허용할 경우, 매개변수명 뒤에 `-OrNull` 접미사를 붙입니다.

참조형 매개변수로 `Null`을 허용해 `Null`이 들어와도 내부에서 적절히 예외처리를 해주는 함수는 Null을 받을 수 있음을 매개변수 이름 뒤에 `-OrNull`을 붙여 명시해줍니다. 


#### 3.3.16 함수가 참조형을 반환할 경우 Null을 반환하지 않습니다.
모든 함수는 참조형 변수를 반환할 때 기본적으로 `Null`을 반환하지 않습니다. 이 가이드에 따라 함수 호출자는 Null 반환 가능성을 고려하지 않으며, 호출 뒤 반환값에 대한 유효성 검사나 Null일 경우를 대비한 예외처리 로직을 만들지 않습니다.

#### 3.3.17 예외적으로 Null 반환이 가능한 함수의 경우 함수명 뒤에 `-OrNull` 접미사를 붙입니다.
함수가 예외적으로 `Null` 참조를 반환할 수 있는 경우, 함수 이름 뒤에 `-OrNull` 접미사를 붙여 `Null`이 반환될 수 있음을 명시합니다. `Null` 반환 가능성이 명확히 드러나므로 함수 호출자는 호출 뒤 유효성 검증과 예외처리 로직을 추가할 것입니다.

#### 3.3.18 이벤트 핸들러 및 디스패처는 `On-` 접두사로 시작해야 합니다.

`이벤트`나 `디스패처`를 처리하는 함수는 모두 `On- 접두사`로 시작한 뒤 [기본 함수 이름 규칙](#332-함수는-항상-동사로-시작해야-합니다)을 따릅니다.

*좋은 예:*
* `OnDeath`
* `OnPickup`
* `OnReceiveMessage`
* `OnTargetChanged`
* `OnClick`
* `OnLeave`


#### 3.3.19 원격 프로시저 호출은 그 대상이 앞에 와야합니다.

`RPC`가 생성될 때마다 `Server`, `Client`, `Multicast` 접두사가 지정되어야 합니다. 대상 접두사 뒤에 [기본 함수 이름 규칙](#332-함수는-항상-동사로-시작해야-합니다)을 따릅니다.

*좋은 예:*
* `ServerFireWeapon`
* `ClientNotifyDeath`
* `MulticastSpawnTracerEffect`

*나쁜 예:*
* `ServerClientBroadcast` 
* `AllNotifyDeath` - `Multicast`를 써야합니다.

<br>

### 3.4 데이터 유효성 검증 원칙

프로젝트에 명확한 데이터 유효성 검증 원칙이 없다면, 블루프린트 작성자는 자신이 직접 초기화한 변수 외에는 모든 데이터가 잠재적으로 유효하지 않을지도 모른다는 걱정을 하게 됩니다. 이런 걱정은 프로젝트 전반에 걸쳐 거의 모든 변수(특히 참조형)에 대해 `IsValid` 체크를 하는 비효율을 낳게 되며, 수시로 나오는 유효성 검증 노드는 블루프린트 가독성도 해치게 됩니다.  

이런 상황을 피하기 위하여, 이 항목은 명확한 데이터 유효성 검증 지점을 제시합니다. 

#### 3.4.1 프로그램의 외부와 내부

데이터 유효성 검증을 수행해야하는 지점은 `프로그램 외부와 내부의 경계지점`입니다. 

`프로그램 외부`는 `자신이 통제할 수 없는 데이터`가 오가는 영역입니다.  
*직접 통제할 수 없는 데이터가 오가는 외부 영역의 예:*
* 플레이어의 키보드 입력
* 네트워크 스트림 데이터
* 로드한 파일의 데이터
* 추적하기 어려운 복잡한 다중 상호작용 상황

`프로그램 내부`는 `모든 데이터를 자신이 완벽히 통제`할 수 있는 영역입니다.  
외부 영역으로부터 데이터를 받아올 일이 없는 로직이나 외부 영역으로부터 데이터를 받아온 뒤 이어지는 로직 등, 사실상 프로그램 내부 구현의 대부분이 여기에 해당합니다. 

#### 3.4.2 경계 지점에서의 데이터 유효성 검증과 예외처리

만약 프로그램 외부에서 내부 영역으로 넘어온 데이터가 유효함을 보장할 수 없다면, 내부 영역에까지 통제되지 않은 데이터가 돌아다니며 외부와 내부의 경계를 모호하게 만들어 버립니다. 이런 프로그램의 구현부는 사실상 모든 부분이 잠재적으로 외부 영역인 것이나 마찬가지이며, 때문에 이런 상황에서 프로그래머는 최대한 방어적인 자세로 모든 변수에 대해 유효성 검증을 할 수밖에 없게 됩니다.

`프로그램 외부와 내부의 경계 지점에서 유효성을 검증하는 이유가 여기에 있습니다.` 이는 외부로부터 들어오는 데이터는 경계 지점에서 유효성을 검증하고, `내부 영역에는 반드시 올바른 데이터만 전달하겠다는 약속`입니다. 프로젝트가 명확한 스타일 가이드에 의해 이 원칙을 준수한다면, 프로그램은 외부와 내부의 경계를 명확히 나눌 수 있게 됩니다.

[Null 매개변수를 허용하는 함수](#3315-함수의-참조형-매개변수가-예외적으로-null을-허용할-경우-매개변수명-뒤에--ornull-접미사를-붙입니다)나 [Null을 반환할 수 있는 함수](#3317-예외적으로-null-반환이-가능한-함수의-경우-함수명-뒤에--ornull-접미사를-붙입니다), `불리언으로 실행 성공여부를 반환하는 함수(eg. 블루프린트의 Teleport, C#의 TryParse ...)`들이 경계 지점에서 흔히 사용되는 함수들입니다.

이 함수들은 기본적으로 데이터의 유효성이 보장되지 않은 상황을 가정하고 있습니다. 데이터가 유효하지 않을 수 있음을 전제했기 때문에 `NUll`을 받거나 반환할 수 있음을 명시하고 있으며, 어떤 기능을 수행하는 함수는 데이터가 유효하지 않아 실행이 실패할 수 있음을 `불리언 실행결과`를 반환하는 것으로 명시하고 있습니다.  

블루프린트의 `Teleport` 함수로 예를 들자면, 액터를 이동시키려는 위치의 `월드 상황은 완전히 미지의 영역`입니다. 런타임 도중 시시각각 변하는 월드의 상황은 컴파일 단계에서는 미리 예단할 수 없는 `외부 영역`입니다. 같은 위치에 이동을 시도하더라도 어느 시점에는 성공하지만 어느 시점에서는 다른 오브젝트에 가로막혀 이동에 실패하는 상황이 발생할 수도 있습니다. 때문에 `Teleport` 함수는 통제된 `내부 영역`으로부터 검증된 `Target`, `Dest Location`, `Dest Rotation` 매개변수를 받지만 그 `실행은 결과를 보장할 수 없는 외부영역`에서 이뤄져야하기 때문에, 외부 월드의 상황이 유효하지 않을 경우 이동에 실패했음을 불리언 변수로 반환합니다. 

이처럼 경계 지점에서는 데이터가 유효하지 않을 수 있음을 가정하고 적절한 유효성 검증과 예외 처리를 수행해야 합니다. 경계 지점에서 유효성을 검증하고 예외 상황을 처리해, 내부로는 유효한 데이터만을 전달해야 합니다.

*경계 지점에서의 유효성 검증과 예외 처리 예:*
* `플레이어로부터 제한된 길이의 입력`을 받아야하는데 `입력 길이가 초과`했을 경우, 올바른 길이를 입력할 때까지 `다시 입력을 요청하거나 허용 길이만큼 문자열을 자른 뒤 내부로 전달`할 수 있습니다.

* `파일을 읽어와 로직을 처리`해야하는데 `파일이 삭제 또는 변형`되었을 경우 `관련 로직을 건너뛰거나 적당히 진행될 수 있게끔 유사 데이터를 생성해 내부로 전달`할 수 있습니다.


#### 3.4.3 유효성 검증을 통과한 프로그램 내부의 로직

이 원칙에 따라, 프로그래머는 경계지점을 통과한 데이터는 모두 유효한 데이터라는 전제 하에 프로그램을 작성할 수 있게 됩니다. 때문에 경계 지점을 지난 내부 영역에서는 더 이상 유효성 검증을 하지 않습니다. 유효한 데이터만 다룬다면 예외 상황도 없다고 전제할 수 있으므로, 내부 영역에서는 예외 처리를 위한 로직도 작성하지 않습니다.

<br>

### 3.5 기타

#### 3.5.1 블루프린트 노드는 대부분의 경우 왼쪽에서 오른쪽으로 진행돼야 합니다.

블루프린트 노드는 스파게티처럼 꼬이기 쉽습니다. 노드가 꼬이지 않도록 항상 실행 순서를 왼쪽에서 오른쪽으로 일관되게 유지해주세요. `동일한 로직의 반복처리`나 `Sequence 노드` 사용 등에서는 `위에서 아래로 진행되어도 괜찮습니다.`

#### 3.5.2 역방향으로 되돌아가는 실행흐름을 만들지 말아야 합니다.

`goto문`을 역방향으로 사용하지 않는 이유와 같습니다. 역방향으로 되돌아가는 실행흐름은 블루프린트를 스파게티처럼 꼬아놓으므로, 그런 실행흐름을 만들어서는 안됩니다. 특정 조건에 따른 반복처리가 필요한 것이라면, 실행흐름을 역방향으로 돌리는 대신 `while`과 같은 반복문을 사용해야 합니다. 일정 딜레이마다 반복실행을 하는 경우라면, 시작점을 이벤트로 만들고 마지막 부분에서 실행흐름을 되돌리는 대신 시작점 이벤트를 호출하십시오.

#### 3.5.3 노드 정렬의 기준은 실행흐름 와이어(흰색 실선) 입니다.

*나쁜 예:*  
![eg.Bad](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/353Bad.png?raw=true "Bad")

*좋은 예:*  
![eg.Good](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/353Good.png?raw=true "Good")

**[⬆ Back to Top](#목차)**

<br>
<br>

## 4. 소스컨트롤 (버전관리)

### 4.1 소스 컨트롤은 반드시 켜져있어야 합니다.

버전관리 프로젝트를 작업 중이라면, 언리얼 엔진 내의 소스컨트롤 기능이 반드시 켜져있어야 합니다. 예외는 없습니다.

### 4.2 플러그인, 프로젝트 세팅을 변경한 뒤 체크인하지 마십시오.

사용 플러그인과 프로젝트 세팅은 프로젝트에 중요한 근본적인 요소입니다. `ProjectFolder\ProjectName.uproject` 파일과 `ProjectFolder\Config` 내의 `.ini` 파일을 소스컨트롤에 제출하지 마세요. 플러그인이나 프로젝트 세팅에 변경이 필요하다면 프로그래머에게 요청해야하며, 그 변경은 프로그래머에 의해 체크인되어야 합니다.


**[⬆ Back to Top](#목차)**

<br>
<br>

## 5. 모델링

### 5.1 한 스태틱 메시와 연관된 머티리얼과 텍스처들은 반드시 올바른 에셋 명명 규칙을 지켜야 합니다.

`SM_Chair_Steel` 스태틱메시에 할당된 머티리얼과 텍스처의 이름은 [에셋 명명 규칙](#1-에셋-명명-규칙)에 따라 다음과 같은 형태가 되어야 합니다.
* `M_Chair_Steel_Frame`
* `M_Chair_Steel_Back`
* `M_Chair_Steel_Cushion`
* `T_Chair_Steel_D`

만약 머티리얼과 텍스처의 이름이 `M_Steel`, `M_Cushion` 같은 형태로 할당되어있다면, 스태틱 메시가 머티리얼 레퍼런스를 잃어버릴 경우 다시 올바른 머티리얼을 찾아 할당하는 일이 어려워집니다. 특히나 텍스처의 이름이 `SM_Chair_Steel` UV에만 사용될 수 있는 맵을 가졌음에도 `T_Steel_D`로 명명되었다면, 모든 철제 재질은 `Steel`이기 때문에 수많은 `Steel` 텍스처 사이에서 `SM_Chair_Steel`에 맞는 단 하나의 텍스처를 찾아야 합니다.

### 5.2 모든 메시는 UV가 있어야 합니다.

### 5.3 메시의 피벗이 메시와 떨어져있어선 안됩니다.

이 문제는 수많은 에셋들이 모여 하나의 씬을 구성하는 FBX를 임포트할 때 흔히 일어납니다. 이런 FBX를 일반적인 방식으로 임포트하면 모든 스태틱 메시 에셋이 자신이 씬에서 배치되어있던 오프셋만큼 떨어진 위치에 피벗을 만들게 됩니다.  

*나쁜 예: 스태틱 메시의 피벗이 떨어져있음*  
![eg.Bad](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/53Bad.png?raw=true "Bad")

이런 `씬 FBX`는 아무 것도 없는 `빈 레벨(Empty Level)`을 만들어 연 뒤 상단의 `파일(File) - 레벨로 임포트(Import Into Level)`를 선택해 가져오십시오.  
`버텍스에서 피벗 굽기(Bake Pivot in Vertex)` 옵션을 체크하면 피벗이 각 스태틱 메시의 중심으로 임포트되며, `계층 타입`은 `Create Level Actors`로 선택하면 빈 레벨에는 FBX 씬 구성대로 스태틱 메시들이 배치됩니다.  
이 레벨은 액터 배치 상태를 저장하기 위해 그대로 `Overview` 이름으로 임포트한 경로에 저장해줍니다.  

*레벨로 임포트(Import Into Level)*  
![eg.importintolevel](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/53ImportIntoLevel.png?raw=true "Import Into Level")

*좋은 예: 스태틱 메시의 피벗이 메시에 가까이 있음 (모듈식 메시에 모서리 피벗 권장)*  
![eg.Good](https://github.com/VLAST-GIT/UE5-StyleGuide/blob/main/images/53Good.png?raw=true "Good")

### 5.4 모든 메시는 콜리전이 있어야 합니다.

스태틱 메시에 실제로 피직스 시뮬레이션이 사용되는지와 관계없이, 모든 메시에는 콜리전이 있어야 합니다. 메시의 콜리전은 피직스 외에도 오클루전, 라이팅 계산 등에 도움을 줍니다. 임포트할 때 자동으로 스태틱 메시 콜리전을 생성하도록 설정해주면 되며, 이는 기본 설정이므로 의도적으로 끄지 않습니다.

### 5.5 모든 메시는 DCC 툴에서부터 올바른 실측 크기로 작업되어야 합니다.

DCC 툴마다 유닛의 단위가 다르기 때문에 `(Maya: mm, UE: cm)` 모델링 에셋이 잘못된 크기로 제작될 수 있습니다. 너무 크거나 너무 작게 임포트된 메시는 트라이앵글 누락, 잘못된 라이팅 등의 문제를 일으킵니다. 임포트 후 액터의 스케일을 조정하는 것으로는 해결되지 않습니다.

잘못된 크기로 임포트된 메시를 액터 스케일 조정으로 사용하면 프로젝트가 그 메시의 올바른 스케일 배수를 따로 알아두고 관리해야하기 때문에 비효율적이기도 합니다. 떄문에 모든 메시는 모델링 단계에서부터 실제 크기와 비슷하게 올바른 크기로 만들어져야 합니다. 

### 5.6 스태틱 메시 FBX Import 옵션

#### 5.6.1 `나나이트 빌드` 체크

UE5의 새로운 기능 나나이트는 자동으로 트라이앵글 밀도를 조정해 별도의 LOD 설정 없이도 수백만 개의 트라이앵글을 가진 메시를 빠르게 렌더링할 수 있도록 만들어줍니다. 프로젝트에 임포트하는 모든 스태틱 메시는 `나나이트 빌드` 옵션을 체크합니다.

#### 5.6.2 `라이트맵 UV 생성` 체크해제

UE5부터는 더이상 미리 계산된 라이트를 사용하지 않습니다. 더이상 라이트 빌드를 사용하지 않으므로, 라이트맵 UV도 생성하지 않습니다.  
무거운 스태틱 메시를 임포트할 때 불필요한 UV 생성이 사라지며 데이터가 줄고 임포트 속도가 빨라지게 됩니다.  


**[⬆ Back to Top](#목차)**

<br>
<br>


## 6. 텍스처

### 6.1 모든 텍스처는 2의 거듭제곱 크기여야 합니다.

GPU와 게임엔진은 2의 거듭제곱 크기를 가진 텍스처 처리에 최적화되어있습니다. UI에 사용되는 텍스처를 제외한 모든 텍스처의 크기는 2의 거듭제곱 크기여야 합니다. 반드시 텍스처가 정사각형일 필요는 없습니다.

*좋은 예:*
* `128 x 512`
* `1024 x 1024`
* `2048 x 1024`
* `1024 x 4096`
* `4096 x 4096`

### 6.2 텍스처의 최대 크기는 8K (8192px) 입니다.

`8192 x 8192` 이상의 크기는 처리할 수 없습니다. 최대 크기가 8K 이기는 하지만, 반드시 필요한 이유가 없다면 이렇게 큰 사이즈의 텍스처는 임포트하지 마십시오. `겉으로 보이는 결과에 큰 차이가 없다면, 텍스처는 작으면 작을수록 좋습니다.`

### 6.3 텍스처에는 올바른 그룹이 할당되어야 합니다.

모든 텍스처에는 텍스처 그룹 속성이 있습니다. 이 속성은 텍스처의 용도에 따라 올바르게 설정되어야 합니다. 예를 들어, 모든 UI 전용 텍스처는 UI 텍스처 그룹에 속해있어야 합니다.

**[⬆ Back to Top](#목차)**

<br>
<br>

## 7. 머티리얼

### 7.1 변수 이름은 파스칼 케이스로 짓되, 단어 사이에 띄어쓰기를 넣어주세요.

머티리얼 변수는 주로 머티리얼 인스턴스에서 보게 됩니다. 머티리얼 인스턴스 사용자는 대부분이 아티스트입니다. 아티스트들이 보기에 편하도록 파스칼 케이스를 기본으로 하되, 단어 사이에 띄어쓰기를 넣어주세요. 블루프린트 변수는 파스칼 케이스를 사용해도 `친근한 변수 이름 표시`에 의해 띄어쓰기를 넣어 노출시켜줘 사용자가 편하게 볼 수 있지만, 머티리얼 변수에는 `친근한 변수 이름 표시`가 지원되지 않기 때문입니다.

*나쁜 예:*
* `BaseColor`
* `basecolor`
* `base_color`
* `EmissivePower`
* `Emissive_Power`

*좋은 예:*
* `Base Color`
* `Emissive Power`

### 7.2 4.27버전부터 도입된 Named Reroutes 기능을 활용해주세요.

머티리얼 노드는 특히 스파게티 노드를 만들기 쉽습니다. 해체할 수 없을 정도로 꼬여버리기 전에 `Named Reroutes` 기능을 활용해 의미있는 기능 단위별로 노드를 묶어 정리해주세요.


**[⬆ Back to Top](#목차)**

<br>
<br>

## 8. 캐릭터 (리깅)

### 8.1 모든 캐릭터는 에픽 표준 본 구조를 따라 리깅되어야 합니다.

캐릭터의 `본 구조`, `본 방향`, `본 이름`은 에픽 표준을 따라 똑같이 제작되어야 합니다. `본 구조`는 일부가 캐릭터마다 조금씩 다를 수도 있지만, 핵심 뼈대의 `본 방향`과 `본 이름`은 반드시 일치해야 합니다.

에픽 표준 캐릭터 예시는 `UE5 3인칭 캐릭터 템플릿`과 `메타휴먼 샘플 프로젝트` 내의 캐릭터를 참고하시면 됩니다. 

에픽의 표준 본 구조를 따르면 개발하는 모든 기능이 메타 휴먼 캐릭터와 쉽게 호환될 수 있으며, 역으로 에픽이 제공하는 컨트롤 리그나 애니메이션 등 여러 템플릿을 사내 캐릭터에 적용하는 것도 쉬워집니다.

*에픽 표준 본 구조 예시:*
<pre>
|-- root
  |-- pelvis
    |-- spine_01
    : |-- spine_02
    :   |-- spine_03 <a href="#asdf">선택적 본, 캐릭터에 따라 없을 수 있음</a>
    :     |-- spine_04 <a href="#asdf">선택적 본, 캐릭터에 따라 없을 수 있음</a>
    :       |-- spine_05 <a href="#asdf">spine 본이 5개 미만이더라도, chest 위치의 spine 본 이름은 "spine_05" 가 되어야 합니다.</a>
    :         |-- clavicle_l
    :         : |-- upperarm_l 
    :         :   |-- upperarm_twist_01_l
    :         :   |-- upperarm_twist_02_l
    :         :   |-- upperarm_twist_03_l <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
    :         :   |-- lowerarm_l
    :         :     |-- lowerarm_twist_01_l
    :         :     |-- lowerarm_twist_02_l
    :         :     |-- lowerarm_twist_03_l <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
    :         :     |-- hand_l
    :         :       |-- index_01_l
    :         :         |-- index_02_l
    :         :           |-- index_03_l
    :         :       |-- middle_01_l
    :         :         |-- middle_02_l
    :         :           |-- middle_03_l
    :         :       |-- pinky_01_l
    :         :         |-- pinky_02_l
    :         :           |-- pinky_03_l
    :         :       |-- ring_01_l
    :         :         |-- ring_02_l
    :         :           |-- ring_03_l
    :         :       |-- thumb_01_l
    :         :         |-- thumb_02_l
    :         :           |-- thumb_03_l
    :         |-- clavicle_r
    :         : |-- upperarm_r
    :         :   |-- upperarm_twist_01_r
    :         :   |-- upperarm_twist_02_r
    :         :   |-- upperarm_twist_03_r <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
    :         :   |-- lowerarm_r
    :         :     |-- lowerarm_twist_01_r
    :         :     |-- lowerarm_twist_02_r
    :         :     |-- lowerarm_twist_03_r <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
    :         :     |-- hand_r
    :         :       |-- index_01_r
    :         :         |-- index_02_r
    :         :           |-- index_03_r
    :         :       |-- middle_01_r
    :         :         |-- middle_02_r
    :         :           |-- middle_03_r
    :         :       |-- pinky_01_r
    :         :         |-- pinky_02_r
    :         :           |-- pinky_03_r
    :         :       |-- ring_01_r
    :         :         |-- ring_02_r
    :         :           |-- ring_03_r
    :         :       |-- thumb_01_r
    :         :         |-- thumb_02_r
    :         :           |-- thumb_03_r                          
    :         |-- neck_01
    :           |-- neck_02 <a href="#asdf">선택적 본, 캐릭터에 따라 없을 수 있음</a>
    :             |-- head
    |-- thigh_l
    : |-- thigh_twist_01_l
    : |-- thigh_twist_02_l <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
    : |-- calf_l
    :   |-- calf_twist_01_l
    :   |-- calf_twist_02_l <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
    :   |-- foot_l
    :     |-- ball_l
    |-- thigh_r
      |-- thigh_twist_01_r
      |-- thigh_twist_02_r <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
      |-- calf_r
        |-- calf_twist_01_r
        |-- calf_twist_02_r <a href="#asdf">01부터 존재하는 twist 본 갯수만큼 넘버링</a>
        |-- foot_r
          |-- ball_r          
</pre>

### 8.2 모듈식 캐릭터 본 구조

VLAST는 캐릭터의 헤어, 상의, 하의, 신발 등을 자유롭게 교체할 수 있도록 모듈식 캐릭터 구조를 사용하고 있습니다.  
캐릭터 모듈은 `Body`, `Hair`, `Face`, `Top`, `Bottom`, `Feet` 6개로 구성되어 있으며, 하위 항목에서 각 모듈별 본 구조 가이드를 다룹니다.

#### 8.2.1 `Body`, `Top`, `Bottom`, `Feet` 모듈

`Body`, `Top`, `Bottom`, `Feet` 모듈들은 `Body`의 스켈레톤을 공유합니다.  
새로 추가되는 상의, 하의 신발 등의 의상은 모두 베이스가 되는 `Body 본`에 할당되어 임포트됩니다.

`메시`는 다음과 같이 설정되어있어야 합니다.
* Body : 헐벗거나 속옷만 입은 기본 바디 메시만 있어야 합니다.
* Top : 상의 메시만 존재해야 합니다.
* Bottom : 하의 메시만 존재해야 합니다.
* Feet : 신발 메시만 존재해야 합니다.

`Body 본`에는 `얼굴과 머리카락 본이 있어선 안됩니다.`  
`Face`와 `Hair`는 별도의 스켈레톤을 사용하기 때문입니다.

#### 8.2.2 `Face` 모듈

`Face` 모듈은 별도의 스켈레톤을 가집니다.   
모든 얼굴 리깅은 `face_root` 본 아래에 존재해야 합니다.  
`Face 스켈레톤`은 `Body 스켈레톤`에서 팔다리가 제거되고, 얼굴 본이 추가됩니다. (어깨 본까지는 있음)

*Face 모듈의 본 구조 예:*
<pre>
|-- root
  |-- pelvis 
    |-- spine_01 
      |-- spine_02 
        |-- spine_03 
          |-- spine_04 
            |-- spine_05  
              |-- clavicle_l 
              |-- clavicle_r 
              |-- neck_01 
                |-- neck_02 
                  |-- head 
                    |-- face_root <a href="#asdf">모든 얼굴 본의 부모</a>
                      |-- 모든 얼굴 본
                      |-- ...
</pre>

#### 8.2.3 `Hair` 모듈

`Hair` 모듈도 별도의 스켈레톤을 가집니다.  
단, `Hair` 에셋들은 각각의 스켈레탈 메시마다 새로운 스켈레톤을 생성해 임포트합니다.

모든 머리카락 리깅은 `hair_root` 본 아래에 존재해야 합니다.  
`hair 스켈레톤`은 `Body 스켈레톤`에서 척추 라인만 남고, 머리카락 본이 추가됩니다.

*Hair 모듈의 본 구조 예:*
<pre>
|-- root
  |-- pelvis 
    |-- spine_01 
      |-- spine_02 
        |-- spine_03 
          |-- spine_04 
            |-- spine_05  
              |-- neck_01 
                |-- neck_02 
                  |-- head 
                    |-- hair_root <a href="#asdf">모든 머리카락 본의 부모</a>
                      |-- 모든 머리카락 본
                      |-- ...
</pre>

**[⬆ Back to Top](#목차)**

<br>
<br>

## 9. 레벨디자인

UE5부터 도입된 월드 파티션 기능의 내부테스트 후, 기존 레벨 작업방식의 레거시 전환여부를 결정한 뒤 작성됩니다.


**[⬆ Back to Top](#목차)**

<br>
<br>

## 10. 라이팅

### 10.1 모든 라이트는 무버블이어야 합니다.

VLAST는 UE5 프로젝트부터 루멘 또는 패스 트레이서를 사용합니다.   
모든 라이트가 동적으로 계산돼 더이상 라이트 빌드가 필요 없으므로, 레벨에는 무버블 라이트만 배치해야 합니다.

### 10.2 더이상 리플렉션 캡처를 사용하지 않습니다.

동일한 이유로, UE5 프로젝트부터는 더이상 리플렉션 베이크가 필요하지 않습니다. 따라서 레벨에 리플렉션 캡처 액터를 배치하지 않습니다.


**[⬆ Back to Top](#목차)**

<br>
<br>







## 스타일 변경 이력

22-04-15 1.0  
22-04-29 1.1  
- 나나이트와 루멘을 반영한 스태틱 메시 임포트, 라이팅 방식 추가
22-05-23 1.2
- BaseEngine.ini 공유 DCC 설정 삭제 (프로젝트별 config 설정으로 대체되었음)


**[⬆ Back to Top](#목차)**
